local ui = loadstring(game:HttpGet("https://raw.githubusercontent.com/Daffy734/code/refs/heads/main/yep"))()

local win = ui:Create({
    Name = "Celeron's GUI (Azure Latch)",
    ThemeColor = Color3.fromRGB(111, 111, 111),
	ThemeGradient = Color3.fromRGB(10, 10, 10),
    StartupSound = "rbxassetid://6958727243",
    ThemeFont = Enum.Font.GothamBold,
	ToggledSideBar = true
})

local hometab = win:Tab("Home")
local maintab = win:Tab("Blatant")
local maintab2 = win:Tab("Silent")
local funtab = win:Tab("Movesets")
local teleporttab = win:Tab("Teleports")
local exploittab = win:Tab("Exploits")
local misctab = win:Tab("Others")
local helptab = win:Tab("Info")

hometab:Label("Script Made By Celeron + Daffy!")
hometab:Label("Join The Discord Server In Info For Updates / Suggestions.")
helptab:Label("Show / Hide GUI: Right Alt")
maintab:Label("Metavision Features.")
teleporttab:Label("Map Teleports, No Prerequisites To Use!")
misctab:Label("Miscellaneous Features, They Give No Advantages In-Game!")
exploittab:Label("This Tab Comes With Useful Features.")

-- buffer string
local buffers = {}
loadstring(game:HttpGet("https://pastebin.com/raw/8XJh7dzh"))()
repeat
    task.wait()
until game.Lighting:FindFirstChild("BUFFERSTRINGS")
for _, val in ipairs(game.Lighting:FindFirstChild("BUFFERSTRINGS"):GetChildren()) do
    buffers[val.Name] = val.Value
end
game.Lighting:FindFirstChild("BUFFERSTRINGS"):Destroy()
--

helptab:Button("Copy Owner Discord Username", "Copies The Owner's Discord Username To Your Clipboard.", function()
local StarterGui = game:GetService("StarterGui")

StarterGui:SetCore("SendNotification", {
    Title = "Discord Username",
    Text = "Copied to your clipboard!",
    Duration = 3,
    Button1 = "alright fella",
})
setclipboard("ghostofcelleron")
end)

helptab:Button("Copy Discord Server Invite", "Copies The Discord Invite To Your Clipboard.", function()
local StarterGui = game:GetService("StarterGui")

StarterGui:SetCore("SendNotification", {
    Title = "Discord Invite",
    Text = "Copied to your clipboard!",
    Duration = 3,
    Button1 = "alright fella",
})
setclipboard("https://discord.gg/8stFYxJv4R")
end)

local rarebanner = math.random(1,50)

if rarebanner == 1 then
    hometab:Banner("17327779381", 385)
else
    hometab:Banner("13308582899", 135)
end

maintab2:Label("Notification Suppression: Useful When Streaming.")

maintab2:Toggle("Suppress Notifications", "Suppresses Notifications On Some Features, Made For Competitive Players.",  function()
    _G.suppressNotifs = not (_G.suppressNotifs or false)
    local StarterGui = game:GetService("StarterGui")

    StarterGui:SetCore("SendNotification", {
        Title = "Notifications",
        Text = _G.suppressNotifs and "Suppressed." or "Removed Suppression.",
        Duration = 1
    })
end)

local spawns = {}
for _, obj in ipairs(workspace:GetDescendants()) do
	if obj:IsA("SpawnLocation") then
		table.insert(spawns, obj)
	end
end

maintab:Button("Metavision V1", "This Feature Emulates Having Isagi's Metavision From The Show.", function()
loadstring(game:HttpGet("https://pastebin.com/raw/FVgs7bQw"))()
end)

maintab:Button("Metavision V2", "Similar To V1, Only Can Be Used Below 1:30 On Clock, Click Puzzle Piece To Activate.", function()
loadstring(game:HttpGet("https://pastebin.com/raw/HfpQBAsF"))()
end)

maintab:Label("Ball Features.")
maintab:Toggle("Auto Goal", "Attempts To Steal The Ball And Score.", function()
    _G.AUTO_GOAL = not _G.AUTO_GOAL
    if _G.AUTO_GOAL then
        game.StarterGui:SetCore("SendNotification", {
            Title = "Auto Goal",
            Text = "Enabled.",
            Duration = 1
        })
		
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local MapFolder = workspace:WaitForChild("map")
local AGoal = MapFolder:WaitForChild("Agoal")
local BGoal = MapFolder:WaitForChild("Bgoal")

local LocalPlayer = Players.LocalPlayer

local function IsInGame()
    local LocalCharacter = LocalPlayer.Character
    if not LocalCharacter then return false end

    local StateFolder = LocalCharacter:FindFirstChild("state")
    if not StateFolder then return false end

    local InGameValue = StateFolder:FindFirstChild("ingame")
    if not InGameValue then return false end

    return InGameValue.Value
end

local function DisableCollisionBoxes()
    local MapFolder = workspace:FindFirstChild("map")
    if not MapFolder then return end

    local GkBarriar = MapFolder:FindFirstChild("gkbarriar")
    local AGoal = MapFolder:FindFirstChild("Agoal")
    local BGoal = MapFolder:FindFirstChild("Bgoal")

    if GkBarriar then
        local ABarriar = GkBarriar:FindFirstChild("A")
        local BBarriar = GkBarriar:FindFirstChild("B")

        if ABarriar then ABarriar.CanCollide = false end
        if BBarriar then BBarriar.CanCollide = false end
    end

    if AGoal then AGoal.CanCollide = false end
    if BGoal then BGoal.CanCollide = false end
end

local function StealBall()
    local LocalCharacter = LocalPlayer.Character
    local LocalHumanoidRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
    local Football = workspace.Terrain:FindFirstChild("Ball")

    if LocalHumanoidRootPart and Football then
        LocalHumanoidRootPart.CFrame = CFrame.new(Football.Position.X, 0, Football.Position.Z)
    end
    
    for _, OtherPlayer in pairs(Players:GetPlayers()) do
        if OtherPlayer ~= LocalPlayer then
            local OtherCharacter = OtherPlayer.Character
            local OtherFootball = OtherCharacter and OtherCharacter:FindFirstChild("Ball")
            local OtherHumanoidRootPart = OtherCharacter and OtherCharacter:FindFirstChild("HumanoidRootPart")

            if OtherFootball and OtherHumanoidRootPart and LocalHumanoidRootPart then
                LocalHumanoidRootPart.CFrame = OtherFootball.CFrame

					local args = {
						buffer.fromstring(buffers["base"]),
						{
							{
								"tackle"
							}
						}
					}
					game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(unpack(args))
            end
        end
    end
end

local function HasBall()
    local LocalCharacter = LocalPlayer.Character
    local Football = LocalCharacter and LocalCharacter:FindFirstChild("Ball")
    return Football ~= nil
end

coroutine.resume(coroutine.create(function()
    RunService.RenderStepped:Connect(function()
        if not _G.AUTO_GOAL then return end
        pcall(function()
            if not IsInGame() then return end
            DisableCollisionBoxes()
            StealBall()
            if HasBall() then
                local LocalCharacter = LocalPlayer.Character
                local LocalRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
                local Goal = LocalPlayer.Team.Name == "A" and BGoal or AGoal

                if LocalRootPart and Goal then
                    LocalRootPart.CFrame = Goal.CFrame

					wait(0.185)

					local args = {
						buffer.fromstring(buffers["base"]),
						{
							{
								"kick",
								20,
								false,
								vector.create(0, 1, 0)
							}
						}
					}
					game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(unpack(args))


                end
            end
        end)
    end)
end))
    else
        game.StarterGui:SetCore("SendNotification", {
            Title = "Auto Goal",
            Text = "Disabled.",
            Duration = 1
        })
    end
end)

maintab:Toggle("Always Ball", "Attempts To Always Hold The Ball (zero gravity while active).", function()
_G.ALWAYS_BALL_ACTIVE = not _G.ALWAYS_BALL_ACTIVE
if _G.ALWAYS_BALL_ACTIVE then
    game.StarterGui:SetCore("SendNotification", {
        Title = "Always Ball",
        Text = "Enabled.",
        Duration = 1
    })

    workspace.Gravity = 0

    spawn(function()
        while _G.ALWAYS_BALL_ACTIVE do
            local LocalPlayer = game.Players.LocalPlayer
            local LocalCharacter = LocalPlayer.Character
            local LocalHumanoidRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
            local Football = workspace.Terrain:FindFirstChild("Ball")
            
            if LocalHumanoidRootPart and Football then
                LocalHumanoidRootPart.CFrame = CFrame.new(Football.Position)
            end

            for _, OtherPlayer in pairs(game.Players:GetPlayers()) do
                if OtherPlayer ~= LocalPlayer then
                    local OtherCharacter = OtherPlayer.Character
                    local OtherFootball = OtherCharacter and OtherCharacter:FindFirstChild("Ball")
                    local OtherHumanoidRootPart = OtherCharacter and OtherCharacter:FindFirstChild("HumanoidRootPart")

                    if OtherFootball and OtherHumanoidRootPart and LocalHumanoidRootPart then
                        LocalHumanoidRootPart.CFrame = OtherFootball.CFrame

						local args = {
							buffer.fromstring(buffers["base"]),
							{
								{
									"tackle"
								}
							}
						}
						game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(unpack(args))

                    end
                end
            end
            
            task.wait(0.1)
        end
    end)
else
    game.StarterGui:SetCore("SendNotification", {
        Title = "Always Ball",
        Text = "Disabled.",
        Duration = 1
    })

    workspace.Gravity = 196.2
end
end)

local flowPart = Instance.new("Part")
flowPart.Size = Vector3.new(30, 1, 30)
flowPart.Anchored = true
flowPart.CanCollide = true
flowPart.Position = Vector3.new(100, 1000, 100)
flowPart.Parent = workspace

maintab:Button("Get Flow (Req. Ball)", "Creates A Safe Area And Spams Kick To Get Flow.", function()
	local player = game:GetService("Players").LocalPlayer
	local char = player.Character or player.CharacterAdded:Wait()
	local root = char:WaitForChild("HumanoidRootPart")
	local original = root.CFrame

	root.CFrame = flowPart.CFrame + Vector3.new(0, 5, 0)

	task.wait(0.67)

	task.spawn(function()
		local remote = game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable")
		local flow = workspace:WaitForChild("characters"):WaitForChild(player.Name):WaitForChild("state"):WaitForChild("flow")

		while flow.Value < 100 do
			remote:FireServer(buffer.fromstring(buffers["base"]), { { "kick", 1, false, vector.create(0, 1, 0) } })
			task.wait(0.01)
		end

		task.wait(0.9)
		root.CFrame = original
	end)
end)

local VirtualInputManager = game:GetService("VirtualInputManager")
local UserInputService = game:GetService("UserInputService")
local Players = game:GetService("Players")
local ContentProvider = game:GetService("ContentProvider")

local isClicking = false
local isEnabled = false

local function preloadAssets()
    local assetsToPreload = {}
    ContentProvider:PreloadAsync(assetsToPreload)
end

local function emulateClickAtMousePosition()
    local mouseLocation = UserInputService:GetMouseLocation()
    local x, y = mouseLocation.X, mouseLocation.Y
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, true, game, 1)
    VirtualInputManager:SendMouseButtonEvent(x, y, 0, false, game, 1)
end

local function teleportToBall()
    local player = Players.LocalPlayer
    local character = player.Character
    local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
    local football = workspace.Terrain:FindFirstChild("Ball")

    if humanoidRootPart and football then
        humanoidRootPart.CFrame = CFrame.new(football.Position)
    end

    for _, otherPlayer in pairs(Players:GetPlayers()) do
        if otherPlayer.Name ~= player.Name then
            local otherCharacter = otherPlayer.Character
            local otherFootball = otherCharacter and otherCharacter:FindFirstChild("Ball")
            local otherHumanoidRootPart = otherCharacter and otherCharacter:FindFirstChild("HumanoidRootPart")

            if otherFootball and otherHumanoidRootPart and humanoidRootPart then
                humanoidRootPart.CFrame = otherFootball.CFrame
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
            end
        end
    end
end

maintab:Button("Steal Ball", "Attempts Repeatedly To Obtain Ball.", function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer

local function HasBall()
    local LocalCharacter = LocalPlayer.Character
    local Football = LocalCharacter and LocalCharacter:FindFirstChild("Ball")
    return Football ~= nil
end

local function StealBall()
    while not HasBall() do
        local LocalCharacter = LocalPlayer.Character
        local LocalHumanoidRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
        local Football = workspace.Terrain:FindFirstChild("Ball")

        if LocalHumanoidRootPart and Football then
            LocalHumanoidRootPart.CFrame = CFrame.new(Football.Position)
        end

        for _, OtherPlayer in pairs(Players:GetPlayers()) do
            if OtherPlayer ~= LocalPlayer then
                local OtherCharacter = OtherPlayer.Character
                local OtherFootball = OtherCharacter and OtherCharacter:FindFirstChild("Ball")
                local OtherHumanoidRootPart = OtherCharacter and OtherCharacter:FindFirstChild("HumanoidRootPart")

                if OtherFootball and OtherHumanoidRootPart and LocalHumanoidRootPart then
                    LocalHumanoidRootPart.CFrame = OtherFootball.CFrame

					local args = {
						buffer.fromstring(buffers["base"]),
							{
								{
								"tackle"
								}
							}
						}
					game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(unpack(args))

                end
            end
        end
        task.wait(0.2)
    end
end

StealBall()
end)

maintab:Button("Bring Ball", "Brings The Ball To Your Position.", function()
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local LocalPlayer = Players.LocalPlayer

local function HasBall()
    local LocalCharacter = LocalPlayer.Character
    local Football = LocalCharacter and LocalCharacter:FindFirstChild("Ball")
    return Football ~= nil
end

local function StealBall()
    while not HasBall() do
        local LocalCharacter = LocalPlayer.Character
        local LocalHumanoidRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
        local Football = workspace.Terrain:FindFirstChild("Ball")

        if LocalHumanoidRootPart and Football then
            LocalHumanoidRootPart.CFrame = CFrame.new(Football.Position)
        end

        for _, OtherPlayer in pairs(Players:GetPlayers()) do
            if OtherPlayer ~= LocalPlayer then
                local OtherCharacter = OtherPlayer.Character
                local OtherFootball = OtherCharacter and OtherCharacter:FindFirstChild("Ball")
                local OtherHumanoidRootPart = OtherCharacter and OtherCharacter:FindFirstChild("HumanoidRootPart")

                if OtherFootball and OtherHumanoidRootPart and LocalHumanoidRootPart then
                    LocalHumanoidRootPart.CFrame = OtherFootball.CFrame

					local args = {
						buffer.fromstring(buffers["base"]),
						{
							{
								"tackle"
							}
						}
					}
					game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(unpack(args))

                end
            end
        end
        task.wait(0.2)
    end
end

spawn(function()
    local LocalCharacter = LocalPlayer.Character
    local LocalHumanoidRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
    local Football = workspace.Terrain:FindFirstChild("Ball")

    if LocalHumanoidRootPart and Football then
        local originalPosition = LocalHumanoidRootPart.CFrame
        LocalHumanoidRootPart.CFrame = CFrame.new(Football.Position)
        StealBall()
        task.wait(0.3)
        LocalHumanoidRootPart.CFrame = originalPosition
    end
end)
end)

local userInputService = game:GetService("UserInputService")
local runService = game:GetService("RunService")
local starterGui = game:GetService("StarterGui")
local player = game.Players.LocalPlayer

_G.ForwardRushEnabled = false
_G.SideDashEnabled = false
_G._rushing = false
_G._sideDashing = false
_G._dashBindsSetup = false
_G._lastForwardRush = 0
_G._lastSideDash = 0

local character, humanoid, rootPart

local function updateCharacter()
    character = player.Character or player.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
end

updateCharacter()
player.CharacterAdded:Connect(updateCharacter)

local function notify(title, text)
    starterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = 2
    })
end

local function forwardRush()
    if _G._rushing or not _G.ForwardRushEnabled or not humanoid or not rootPart then return end
    if tick() - _G._lastForwardRush < 0.2 then return end
    _G._lastForwardRush = tick()
    _G._rushing = true

    local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
    local animation = Instance.new("Animation")
    animation.AnimationId = "rbxassetid://79394729551302"
    local animationTrack = animator:LoadAnimation(animation)
    animationTrack:Play()

    task.delay(0.05, function()
        if animationTrack.IsPlaying then
            local sound = Instance.new("Sound")
            sound.SoundId = "rbxassetid://105267293181745"
            sound.Parent = rootPart
            sound:Play()
            sound.Ended:Connect(function() sound:Destroy() end)
        end
    end)

    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e5, 0, 1e5)
    bv.Parent = rootPart

    local dashId = "ForwardRush_" .. tostring(os.clock())
    runService:BindToRenderStep(dashId, Enum.RenderPriority.Character.Value, function()
        if not rootPart or not rootPart.Parent then
            runService:UnbindFromRenderStep(dashId)
            bv:Destroy()
            _G._rushing = false
            return
        end
        bv.Velocity = rootPart.CFrame.LookVector * 100
    end)

    task.delay(0.5, function()
        runService:UnbindFromRenderStep(dashId)
        bv:Destroy()
        _G._rushing = false
    end)
end

local function sideDash(direction)
    if _G._sideDashing or not _G.SideDashEnabled or not humanoid or not rootPart then return end
    if tick() - _G._lastSideDash < 0.15 then return end
    _G._lastSideDash = tick()
    _G._sideDashing = true

    local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
    local animation = Instance.new("Animation")
    animation.AnimationId = direction == "right" and "rbxassetid://114016332539655" or "rbxassetid://100207093237932"
    local animationTrack = animator:LoadAnimation(animation)
    animationTrack:Play()

    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://71212694698006"
    sound.Parent = rootPart
    sound:Play()
    sound.Ended:Connect(function() sound:Destroy() end)

    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e5, 0, 1e5)
    bv.Parent = rootPart

    local dashId = "SideDash_" .. tostring(os.clock())
    runService:BindToRenderStep(dashId, Enum.RenderPriority.Character.Value, function()
        if not rootPart or not rootPart.Parent then
            runService:UnbindFromRenderStep(dashId)
            bv:Destroy()
            _G._sideDashing = false
            return
        end
        local rightVec = rootPart.CFrame.RightVector
        bv.Velocity = rightVec * (direction == "right" and 75 or -75)
    end)

    task.delay(0.4, function()
        runService:UnbindFromRenderStep(dashId)
        bv:Destroy()
        _G._sideDashing = false
    end)
end

maintab:Label("No Cooldown Features.")
maintab:Toggle("No Rush Cooldown", "Emulates Having No Rush Cooldown.", function()
    _G.ForwardRushEnabled = not _G.ForwardRushEnabled
    notify("No Rush CD", _G.ForwardRushEnabled and "Enabled." or "Disabled.")
end)

maintab:Toggle("No Side Dash Cooldown", "Emulates Having No Side Dash Cooldown.", function()
    _G.SideDashEnabled = not _G.SideDashEnabled
    notify("No Side Dash CD", _G.SideDashEnabled and "Enabled." or "Disabled.")
end)

if not _G._dashBindsSetup then
    _G._dashBindsSetup = true

    userInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end

        if input.KeyCode == Enum.KeyCode.F then
            forwardRush()
        elseif input.KeyCode == Enum.KeyCode.Q then
            local isA = userInputService:IsKeyDown(Enum.KeyCode.A)
            local isD = userInputService:IsKeyDown(Enum.KeyCode.D)
            if isD then
                sideDash("right")
            elseif isA then
                sideDash("left")
            end
        end
    end)
end

maintab:Label("Break Ball Features.")
maintab:Button("Break Ball (Player Method, Req. Ball)", "Breaks The Ball By Going Extremely High Up.", function()
    local baseplatePosition = Vector3.new(-190, 14864566, 492)
    local partSize = Vector3.new(10, 1, 10)
    local gap = 0

    for x = 0, 2 do
        for z = 0, 2 do
            local part = Instance.new("Part")
            part.Size = partSize
            part.Anchored = true
            part.Position = baseplatePosition + Vector3.new(x * (partSize.X + gap), 0, z * (partSize.Z + gap))
            part.Parent = workspace
        end
    end

    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()

    character:WaitForChild("HumanoidRootPart").CFrame =
        CFrame.new(baseplatePosition + Vector3.new(0, 100000000000000, 0))
end)

maintab:Button("Break Ball (Ball Method, Req. Ball)", "Breaks The Ball By Kicking It Out Of Bounds.", function()
local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
local virtualInputManager = game:GetService("VirtualInputManager")

if humanoidRootPart then
    local originalPosition = humanoidRootPart.Position
    humanoidRootPart.CFrame = CFrame.new(Vector3.new(-390, 475, 354))
	task.wait(0.3)
    virtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
    task.wait(0.1)
    virtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
	task.wait(0.3)
    humanoidRootPart.CFrame = CFrame.new(originalPosition)
end
end)

maintab:Button("Permanent Break Ball (Req. Ball)", "Breaks The Ball By Placing It In The Void.", function()
workspace.FallenPartsDestroyHeight = -50000
game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(1, -49999, 1))
end)

maintab2:Label("Original Ball Magnet: Allows You To Grab The Ball From Further Away.")

maintab2:Toggle("Ball Magnet", "The Original Ball Magnet, Always On Max Range.", function()
local remote = game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable")

getgenv().ballMagnetActive = not getgenv().ballMagnetActive

game.StarterGui:SetCore("SendNotification", {
	Title = "Ball Magnet",
	Text = getgenv().ballMagnetActive and "Enabled." or "Disabled.",
	Duration = 1
})

if getgenv().ballMagnetActive then
	if getgenv().ballMagnetConnection then
		getgenv().ballMagnetConnection:Disconnect()
	end

	getgenv().ballMagnetConnection = task.spawn(function()
		while getgenv().ballMagnetActive do
			pcall(function()
				remote:FireServer(buffer.fromstring(buffers["grabball"]))
			end)
			task.wait()
		end
	end)
else
	if getgenv().ballMagnetConnection then
		getgenv().ballMagnetConnection = nil
	end
end
end)

local magnetEnabled = false
local beganConnection
local endedConnection
local holding = false

local userInputService = game:GetService("UserInputService")
local remote = game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable")

maintab2:Toggle("Ball Magnet (Bind: M2, Click / Hold.)", "Similar To The Original, But Only Activate While Right Click Is Held Down.", function()
    if not magnetEnabled then
        magnetEnabled = true

        beganConnection = userInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            if input.UserInputType == Enum.UserInputType.MouseButton2 then
                holding = true
                task.spawn(function()
                    while holding do
                        remote:FireServer(buffer.fromstring(buffers["grabball"]))
                        task.wait(0.05)
                    end
                end)
            end
        end)

        endedConnection = userInputService.InputEnded:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            if input.UserInputType == Enum.UserInputType.MouseButton2 then
                holding = false
            end
        end)

        starterGui:SetCore("SendNotification", {
            Title = "Ball Magnet (M2 Hold)",
            Text = "Enabled.",
            Duration = 3
        })
    else
        magnetEnabled = false
        holding = false

        if beganConnection then beganConnection:Disconnect() beganConnection = nil end
        if endedConnection then endedConnection:Disconnect() endedConnection = nil end



        starterGui:SetCore("SendNotification", {
            Title = "Ball Magnet (M2 Hold)",
            Text = "Disabled.",
            Duration = 3
        })
    end
end)

maintab2:Toggle("Ball Magnet Hitbox", "Shows The Magnet's Hitbox On The Ball.", function()

	getgenv().ballHitboxActive = not getgenv().ballHitboxActive

	game.StarterGui:SetCore("SendNotification", {
		Title = "Ball Magnet Hitbox",
		Text = getgenv().ballHitboxActive and "Enabled." or "Disabled.",
		Duration = 1
	})

	local RunService = game:GetService("RunService")

	local function removeHitbox()
		if getgenv().ballHitbox then
			getgenv().ballHitbox:Destroy()
			getgenv().ballHitbox = nil
		end
	end

	local function stopLoop()
		if getgenv().ballHitboxLoop then
			getgenv().ballHitboxLoop:Disconnect()
			getgenv().ballHitboxLoop = nil
		end
	end

	if not getgenv().ballHitboxActive then
		stopLoop()
		removeHitbox()
		return
	end

	stopLoop()

	getgenv().ballHitboxLoop = RunService.Heartbeat:Connect(function()

		if not getgenv().ballHitboxActive then
			stopLoop()
			removeHitbox()
			return
		end

		local terrain = workspace:FindFirstChild("Terrain")
		local ball = terrain and terrain:FindFirstChild("Ball")

		if not ball or not ball:IsA("BasePart") then
			removeHitbox()
			return
		end

		if not getgenv().ballHitbox then
			local hitbox = Instance.new("Part")
			hitbox.Name = "BallMagnetHitbox"
			hitbox.Shape = Enum.PartType.Ball
			hitbox.Size = Vector3.new(25, 25, 25)
			hitbox.Material = Enum.Material.Neon
			hitbox.Color = Color3.fromRGB(15, 155, 155)
			hitbox.Transparency = 0.9
			hitbox.CanCollide = false
			hitbox.CanTouch = false
			hitbox.CanQuery = false
			hitbox.Anchored = false
			hitbox.Massless = true
			hitbox.CFrame = ball.CFrame
			hitbox.Parent = ball

			local weld = Instance.new("WeldConstraint")
			weld.Part0 = ball
			weld.Part1 = hitbox
			weld.Parent = hitbox

			getgenv().ballHitbox = hitbox
		end
	end)
end)

maintab2:Label("Ball Magnet Radius: Same As Above, But The Range Is Changeable.")

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local remote = ReplicatedStorage:WaitForChild("ByteNetReliable")
local localPlayer = Players.LocalPlayer

getgenv().ballMagnetRadius = 1

maintab2:Slider("Ball Magnet Radius", 1, 1, 25, 0.5, function(v)
    getgenv().ballMagnetRadius = v
end)

if getgenv().ballMagnetConnection then
    getgenv().ballMagnetConnection:Disconnect()
end

local lastFire = 0
local FIRE_INTERVAL = 0.1
local hrp

local function setupCharacter(char)
    hrp = char:WaitForChild("HumanoidRootPart", 10)
end

if localPlayer.Character then
    setupCharacter(localPlayer.Character)
end

localPlayer.CharacterAdded:Connect(function(char)
    setupCharacter(char)
end)

getgenv().ballMagnetConnection = RunService.Heartbeat:Connect(function()
    local radius = getgenv().ballMagnetRadius or 1
    if radius < 2 then return end

    local ball = Workspace.Terrain:FindFirstChild("Ball")
    if not ball then return end

    if hrp then
        local dist = (hrp.Position - ball.Position).Magnitude
        if dist <= radius and (time() - lastFire) >= FIRE_INTERVAL then
            lastFire = time()
            pcall(function()
                remote:FireServer(buffer.fromstring(buffers["grabball"]))
            end)
        end
    end
end)

maintab2:Toggle("Ball Magnet Radius Hitbox", "Shows The Magnet's Hitbox On The Ball.", function()
	getgenv().ballRangeVizEnabled = not getgenv().ballRangeVizEnabled

	game.StarterGui:SetCore("SendNotification", {
		Title = "Ball Magnet Radius Hitbox",
		Text = getgenv().ballRangeVizEnabled and "Enabled." or "Disabled.",
		Duration = 1
	})

	local RunService = game:GetService("RunService")

	local function removeHitbox()
		if getgenv().ballRangeHitbox then
			getgenv().ballRangeHitbox:Destroy()
			getgenv().ballRangeHitbox = nil
		end
	end

	local function stopLoop()
		if getgenv().ballRangeLoop then
			getgenv().ballRangeLoop:Disconnect()
			getgenv().ballRangeLoop = nil
		end
	end

	if not getgenv().ballRangeVizEnabled then
		stopLoop()
		removeHitbox()
		return
	end

	stopLoop()

	getgenv().ballRangeLoop = RunService.Heartbeat:Connect(function()
		if not getgenv().ballRangeVizEnabled then
			stopLoop()
			removeHitbox()
			return
		end

		local terrain = workspace:FindFirstChild("Terrain")
		local ball = terrain and terrain:FindFirstChild("Ball")
		if not ball or not ball:IsA("MeshPart") then
			removeHitbox()
			return
		end

		local radius = getgenv().ballMagnetRadius or 1
		if radius < 2 then
			removeHitbox()
			return
		end

		if not getgenv().ballRangeHitbox then
			local hitbox = Instance.new("Part")
			hitbox.Name = "BallMagnetRange"
			hitbox.Shape = Enum.PartType.Ball
			hitbox.Material = Enum.Material.Neon
			hitbox.Color = Color3.fromRGB(15, 155, 155)
			hitbox.Transparency = 0.9
			hitbox.CanCollide = false
			hitbox.CanTouch = false
			hitbox.CanQuery = false
			hitbox.Anchored = true
			hitbox.Massless = true
			hitbox.Parent = workspace
			getgenv().ballRangeHitbox = hitbox
		end

		local d = radius * 2
		local hitbox = getgenv().ballRangeHitbox
		hitbox.Size = Vector3.new(d, d, d)
		hitbox.CFrame = ball.CFrame
	end)
end)


maintab2:Label("Set The Auto-Counter Number To Your Character's Counter Move!")

maintab2:Button("Show Keybinds", "Shows The Keybinds For The Toggle Keybinds Feature.", function()
    local StarterGui = game:GetService("StarterGui")

    StarterGui:SetCore("SendNotification", {
        Title = "Keybinds",
        Text = "Z = Auto-Dribble\nX = Move One\nC = Move Two",
        Duration = 4
    })

    task.delay(0.5, function()
        StarterGui:SetCore("SendNotification", {
            Title = "Keybinds",
            Text = "V = Move Three\nN = Move Four\nM = Move Five.",
            Duration = 4
        })
    end)
end)

_G.suppressNotifs = false

_G.autoSkills = {
	["toggleDetection"] = "dribble",
	["toggleCounter1"] = "skill1",
	["toggleCounter2"] = "skill2",
	["toggleCounter3"] = "skill3",
	["toggleCounter4"] = "skill4",
	["toggleCounter5"] = "skill5"
}

buffer = buffer or {
	fromstring = function(str)
		return str
	end
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local ANIMATION_ID = "rbxassetid://109744655458082"
local cooldowns = {}

function notify(title, text, duration)
	if not _G.suppressNotifs then
		StarterGui:SetCore("SendNotification", {
			Title = title,
			Text = text,
			Duration = duration or 2
		})
	end
end

RunService.Stepped:Connect(function()
	local char = player.Character
	local root = char and char:FindFirstChild("HumanoidRootPart")
	if not root then return end

	for _, target in ipairs(Players:GetPlayers()) do
		if target ~= player and target.Character and target.Team ~= player.Team then
			local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
			local targetHumanoid = target.Character:FindFirstChild("Humanoid")
			local animator = targetHumanoid and targetHumanoid:FindFirstChildOfClass("Animator")

			if targetHRP and animator then
				local distance = (root.Position - targetHRP.Position).Magnitude
				if distance <= 35 then
					local now = tick()
					local last = cooldowns[target] or 0
					if now - last >= 0.5 then
						for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
							if track.Animation.AnimationId == ANIMATION_ID then
								cooldowns[target] = now

								for _, toggleKey in ipairs({
									"toggleDetection",
									"toggleCounter1",
									"toggleCounter2",
									"toggleCounter3",
									"toggleCounter4",
									"toggleCounter5"
								}) do
									local skillName = _G.autoSkills[toggleKey]
									if _G[toggleKey] and skillName then
										local args
										if skillName == "dribble" then
											args = {
												buffer.fromstring(buffers["base"]),
												{ { skillName, false } }
											}
										else
											args = {
												buffer.fromstring(buffers["base"]),
												{ { skillName } }
											}
										end
										ReplicatedStorage:WaitForChild("ByteNetReliable"):FireServer(unpack(args))
									end
								end
								break
							end
						end
					end
				end
			end
		end
	end
end)

function createAutoCounter(label, toggleKey)
	maintab2:Toggle(label, function()
		_G[toggleKey] = not (_G[toggleKey] or false)
		notify(label, _G[toggleKey] and "Enabled." or "Disabled.", 3)
	end)
end

maintab2:Toggle("Toggle Keybinds", "Enables Auto Dribble / Auto Counter Features Via Keybinds, Check Info For Binds.", function()
	_G.keybindsEnabled = not (_G.keybindsEnabled or false)
	notify("Keybinds", _G.keybindsEnabled and "Enabled." or "Disabled.", 3)
end)

createAutoCounter("Auto Dribble", "toggleDetection")
createAutoCounter("Auto Counter (Move One)", "toggleCounter1")
createAutoCounter("Auto Counter (Move Two)", "toggleCounter2")
createAutoCounter("Auto Counter (Move Three)", "toggleCounter3")
createAutoCounter("Auto Counter (Move Four)", "toggleCounter4")
createAutoCounter("Auto Counter (Move Five)", "toggleCounter5")

if not _G._keybindSetup then
	_G._keybindSetup = true

	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed or not _G.keybindsEnabled then return end

		local keyMap = {
			[Enum.KeyCode.Z] = {"toggleDetection", "Auto-Dribble"},
			[Enum.KeyCode.X] = {"toggleCounter1", "Auto-Counter (Move One)"},
			[Enum.KeyCode.C] = {"toggleCounter2", "Auto-Counter (Move Two)"},
			[Enum.KeyCode.V] = {"toggleCounter3", "Auto-Counter (Move Three)"},
			[Enum.KeyCode.N] = {"toggleCounter4", "Auto-Counter (Move Four)"},
			[Enum.KeyCode.M] = {"toggleCounter5", "Auto-Counter (Move Five)"}
		}

		local mapping = keyMap[input.KeyCode]
		if mapping then
			local toggleKey, label = unpack(mapping)
			_G[toggleKey] = not (_G[toggleKey] or false)
			notify(label, _G[toggleKey] and "Enabled." or "Disabled.", 3)
		end
	end)
end

maintab:Label("Auto Goal Features.")

maintab:Button("Isagi U-20 Goal", "Attempts To Do Isagi's U-20 Auto Goal By Teleporting To The Designated Area.", function()
local plr = game.Players.LocalPlayer
if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
    local hrp = plr.Character.HumanoidRootPart
    
    if plr.Team == game.Teams:FindFirstChild("A") then
        hrp.CFrame = CFrame.new(-459, 3, 862)
    elseif plr.Team == game.Teams:FindFirstChild("B") then
        hrp.CFrame = CFrame.new(-611, 3, 1682) * CFrame.Angles(0, math.rad(180), 0)
    end
    if plr.Character and plr.Character:FindFirstChild("Humanoid") then
    plr.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
    task.wait(0.2)
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Two, false, game)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Two, false, game)
end
end)

maintab:Button("Barou Devour Goal", "Attempts To Do Barou's Devour Auto Goal By Teleporting Behind Two Enemy Players.", function()
local plr = game.Players.LocalPlayer

			local function countEnimTeamMembers()
				local op = game.Teams:FindFirstChild("A")
				if plr.Team == game.Teams:FindFirstChild("A") then
					op = game.Teams:FindFirstChild("B")
				end
				local count = 0
				for _, player in ipairs(game.Players:GetPlayers()) do
					if player.Team == op then
						count += 1
					end
				end
				return count
			end
			
			local function getTwoRandomEnemies()
				local enemies = {}
				local op = game.Teams:FindFirstChild("A")
				if plr.Team == game.Teams:FindFirstChild("A") then
					op = game.Teams:FindFirstChild("B")
				end
				
				for _, player in ipairs(game.Players:GetPlayers()) do
					if player ~= plr and player.Team == op then
						table.insert(enemies, player)
					end
				end
				
				for i = #enemies, 2, -1 do
					local j = math.random(1, i)
					enemies[i], enemies[j] = enemies[j], enemies[i]
				end

				return enemies[1], enemies[2]
			end
			
			if countEnimTeamMembers() >= 2 then
				local p1, p2 = getTwoRandomEnemies()
				if not p1 or not p2 then return end
				
				local op = game.Teams:FindFirstChild("A")
				if plr.Team == game.Teams:FindFirstChild("A") then
					op = game.Teams:FindFirstChild("B")
				end

				local function tpToPlayer(targetPlayer)
					local char = plr.Character or plr.CharacterAdded:Wait()
					local root = char:WaitForChild("HumanoidRootPart")
					local targetRoot = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")

					if root and targetRoot then
						root.CFrame = targetRoot.CFrame
					end
				end

				tpToPlayer(p1)
				task.wait(0.3)
				tpToPlayer(p2)
				
				task.wait(0.3)
				
				if plr.Team == game.Teams:FindFirstChild("A") then
					plr.Character.HumanoidRootPart.Position = Vector3.new(-625, 3, 925)
				elseif plr.Team == game.Teams:FindFirstChild("B") then
					plr.Character.HumanoidRootPart.Position = Vector3.new(-588, 3, 1643)
				end
			end
end)

maintab:Button("Nagi Dream Goal", "Attempts To Do Nagi's Control Move Auto Goal In Flow.", function()
local plr = game.Players.LocalPlayer
if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
    local hrp = plr.Character.HumanoidRootPart
    
    if plr.Team == game.Teams:FindFirstChild("A") then
        hrp.CFrame = CFrame.new(-459, 3, 862)
    elseif plr.Team == game.Teams:FindFirstChild("B") then
        hrp.CFrame = CFrame.new(-611, 3, 1682) * CFrame.Angles(0, math.rad(180), 0)
    end
    if plr.Character and plr.Character:FindFirstChild("Humanoid") then
    plr.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
    end
    task.wait(0.2)
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Two, false, game)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Two, false, game)
end
end)

maintab:Button("Shidou Back-Heel Goal", "Attempts To Do Shidou's Back Heel Auto Goal, MUST BE OVERTIME.", function()
local plr = game.Players.LocalPlayer
				if plr.Team == game.Teams:FindFirstChild("A") then
					plr.Character.HumanoidRootPart.Position = Vector3.new(-625, 3, 925)
				elseif plr.Team == game.Teams:FindFirstChild("B") then
					plr.Character.HumanoidRootPart.Position = Vector3.new(-588, 3, 1643)
				end
				task.wait(0.25)
                VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Two, false, game)
                VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Two, false, game)
end)

maintab:Label("Other Blatant Features.")
local blatantEnabled, loopConnection = false, nil
local rs = game:GetService("RunService")
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")

local function setCollide(state)
    local a = ws.map.gkbarriar.Abarriar
    local b = ws.map.gkbarriar.Bbarriar
    local ag = ws.map.Agoal
    local bg = ws.map.Bgoal

    if a then a.CanCollide = state end
    if b then b.CanCollide = state end
    if ag then ag.CanCollide = state end
    if bg then bg.CanCollide = state end
end

maintab:Toggle("Blatant Mode", "Removes Collisions With Goal Boxes.", function()
    blatantEnabled = not blatantEnabled
    if blatantEnabled then
        loopConnection = rs.Heartbeat:Connect(function() setCollide(false) end)
        sg:SetCore("SendNotification",{Title="Blatant Mode",Text="Enabled.",Duration=3})
    else
        if loopConnection then loopConnection:Disconnect() loopConnection = nil end
        setCollide(true)
        sg:SetCore("SendNotification",{Title="Blatant Mode",Text="Disabled.",Duration=3})
    end
end)

local nostun = false
local p = game.Players.LocalPlayer

local function apply()
    if not nostun then return end
    local c = p.Character or p.CharacterAdded:Wait()
    local h = c:WaitForChild("Humanoid")
    h.WalkSpeed = 40
end

p.CharacterAdded:Connect(function()
    if nostun then apply() end
end)

maintab:Toggle("No Stun", "Overrides The Stunned State So You Can Move.", function(v)
    nostun = v
    if v then
        game.StarterGui:SetCore("SendNotification", {Title="No Stun", Text="Enabled"})
    else
        game.StarterGui:SetCore("SendNotification", {Title="No Stun", Text="Disabled"})
    end
end)

game:GetService("RunService").RenderStepped:Connect(function()
    if nostun then apply() end
end)

local running = false
local sg = game:GetService("StarterGui")

maintab:Toggle("Spam Brick Sound (5v5 + GK Only.)", "This SHOULD Be Self Explanatory.", function(state)
    running = state

    if running then
        sg:SetCore("SendNotification", {
            Title = "Brick Spam";
            Text = "Enabled.";
            Duration = 3
        })

        task.spawn(function()
            local char = game.Players.LocalPlayer.Character
            local root = char:WaitForChild("HumanoidRootPart")

            local team = game.Players.LocalPlayer.Team and game.Players.LocalPlayer.Team.Name
            local targetPos

            if team == "A" then
                targetPos = Vector3.new(-510, 3, 1706)
            elseif team == "B" then
                targetPos = Vector3.new(-559, 3, 843)
            end

            if targetPos then
                while running do
                    root.CFrame = CFrame.new(targetPos)
                    wait(0.1)

                    local args = {
                        buffer.fromstring(buffers["base"]),
                        {
                            {
                                "kick",
                                27,
                                false,
                                vector.create(0, 1, 0)
                            }
                        }
                    }
                    game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(unpack(args))

                    task.wait(0.05)
                end
            end
        end)
    else
        sg:SetCore("SendNotification", {
            Title = "Brick Spam";
            Text = "Disabled.";
            Duration = 3
        })
    end
end)

maintab:Label("Additional Fun Features!")

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")

local plr = Players.LocalPlayer
local mouse = plr:GetMouse()
local Camera = workspace.CurrentCamera

local passpass = ReplicatedStorage:WaitForChild("ByteNetReliable")

getgenv().InfiniteRangePassing = false
local busy = false

local keyToSkill = {
	[Enum.KeyCode.One]   = "skill1",
	[Enum.KeyCode.Two]   = "skill2",
	[Enum.KeyCode.Three] = "skill3",
	[Enum.KeyCode.Four]  = "skill4",
}

local function getClosestPlayerToCursor()
	local mousePos = UserInputService:GetMouseLocation()
	local closestChar
	local closestDist = math.huge

	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= plr and p.Team == plr.Team then
			local char = p.Character
			local hum = char and char:FindFirstChild("Humanoid")
			local hrp = char and char:FindFirstChild("HumanoidRootPart")

			if hum and hrp and hum.Health > 0 then
				local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
				if onScreen then
					local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
					if dist < closestDist then
						closestDist = dist
						closestChar = char
					end
				end
			end
		end
	end

	return closestChar
end

UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if not getgenv().InfiniteRangePassing then return end
	if busy then return end
	if plr.Team == game.Teams.lobby then return end

	local skillName = keyToSkill[input.KeyCode]
	if not skillName then return end

	local targetChar = getClosestPlayerToCursor()
	if not targetChar then return end

	busy = true

	passpass:FireServer(
		buffer.fromstring(buffers["base"]),
		{
			{
				skillName,
				targetChar
			}
		}
	)

	task.delay(0.1, function()
		busy = false
	end)
end)

maintab:Toggle("Infinite Range Passing", "Pass to closest teammate to your mouse from anywhere.", function(v)
	getgenv().InfiniteRangePassing = v
	StarterGui:SetCore("SendNotification", {
		Title = "Infinite Pass",
		Text = v and "Enabled." or "Disabled.",
		Duration = 5
	})
end)


maintab:Button("Goalkeeper Anywhere (Rejoin To Disable.) (Credit: someone cool..)", "Allows You To Do GK Side Dashes Instead!", function()
game:GetService("StarterGui"):SetCore("SendNotification", {
			Title = "Goalkeeper Anywhere",
			Text = "If You Don't See GK Animations, Your Executor Doesn't Support The Required Functions.",
			Duration = 10,
            Button1 = "ok my executor is fine",
            Button2 = "aw man my executor sucks"
})

local module = game:GetService("ReplicatedStorage").util.actionUtil
local env = require(module)

local oldfunc
oldfunc = hookfunction(env.checkGK, function (...)
    return true
end)
end)

maintab:Label("Distance Move Buffs, Set To Zero To Disable.")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

local player = Players.LocalPlayer

getgenv().distance = 0
local duration = 0.45
local boostCooldownTime = 0.15
local naru_anim = "rbxassetid://82240286756891"

getgenv().moving = false
getgenv().boostCooldown = false
getgenv().animationDetected = false
getgenv().armTime = 0

maintab:Slider("Naruhaya Footwork Distance", 0, 0, 200, 1, function(v)
	getgenv().distance = v
end)

local function hookFootwork(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and track.Animation.AnimationId == naru_anim
		and os.clock() >= getgenv().armTime then
			getgenv().animationDetected = true
		end
	end)
end

if player.Character then hookFootwork(player.Character) end
player.CharacterAdded:Connect(hookFootwork)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Two then return end
	if getgenv().distance <= 0 then return end
	if getgenv().moving or getgenv().boostCooldown then return end

	getgenv().armTime = os.clock()
	getgenv().animationDetected = false
	local currentDistance = getgenv().distance

	task.delay(0.33, function()
		if not getgenv().animationDetected or getgenv().boostCooldown then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving = true
		getgenv().boostCooldown = true

		local speed = currentDistance / duration
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z).Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving = false
				task.delay(boostCooldownTime, function()
					getgenv().boostCooldown = false
				end)
			end
		end)
	end)
end)

getgenv().distance1 = 0
local duration1 = 0.625
local boostCooldownTime1 = 0.15
local raum_anims = {
	["rbxassetid://81582265162782"] = true
}

getgenv().moving1 = false
getgenv().boostCooldown1 = false
getgenv().animationDetected1 = false
getgenv().armTime1 = 0

maintab:Slider("Raumdeuter Distance", 0, 0, 200, 1, function(v)
	getgenv().distance1 = v
end)

local function hookRaum(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and raum_anims[track.Animation.AnimationId]
		and os.clock() >= getgenv().armTime1 then
			getgenv().animationDetected1 = true
		end
	end)
end

if player.Character then hookRaum(player.Character) end
player.CharacterAdded:Connect(hookRaum)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Two then return end
	if getgenv().distance1 <= 0 then return end
	if getgenv().moving1 or getgenv().boostCooldown1 then return end

	getgenv().armTime1 = os.clock()
	getgenv().animationDetected1 = false
	local currentDistance = getgenv().distance1

	task.delay(0.17, function()
		if not getgenv().animationDetected1 or getgenv().boostCooldown1 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving1 = true
		getgenv().boostCooldown1 = true

		local speed = currentDistance / duration1
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z).Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving1 = false
				task.delay(boostCooldownTime1, function()
					getgenv().boostCooldown1 = false
				end)
			end
		end)
	end)
end)

getgenv().distance2 = 0
local duration2 = 0.75
local boostCooldownTime2 = 0.15
local drac_anim = "rbxassetid://95359966795185"

getgenv().moving2 = false
getgenv().boostCooldown2 = false
getgenv().animationDetected2 = false
getgenv().armTime2 = 0

maintab:Slider("Draconic Rush Distance", 0, 0, 200, 1, function(v)
	getgenv().distance2 = v
end)

local function hookDraconic(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and track.Animation.AnimationId == drac_anim
		and os.clock() >= getgenv().armTime2 then
			getgenv().animationDetected2 = true
		end
	end)
end

if player.Character then hookDraconic(player.Character) end
player.CharacterAdded:Connect(hookDraconic)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Three then return end
	if getgenv().distance2 <= 0 then return end
	if getgenv().moving2 or getgenv().boostCooldown2 then return end

	getgenv().armTime2 = os.clock()
	getgenv().animationDetected2 = false
	local currentDistance = getgenv().distance2

	task.delay(0.17, function()
		if not getgenv().animationDetected2 or getgenv().boostCooldown2 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving2 = true
		getgenv().boostCooldown2 = true

		local speed = currentDistance / duration2
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z).Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving2 = false
				task.delay(boostCooldownTime2, function()
					getgenv().boostCooldown2 = false
				end)
			end
		end)
	end)
end)

getgenv().distance3 = 0
local duration3 = 0.25
local boostCooldownTime3 = 0.15
local step_anim = "rbxassetid://84063609284472"

getgenv().moving3 = false
getgenv().boostCooldown3 = false
getgenv().animationDetected3 = false
getgenv().armTime3 = 0

maintab:Slider("Step Overs Distance", 0, 0, 200, 1, function(v)
	getgenv().distance3 = v
end)

local function hookStep(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and track.Animation.AnimationId == step_anim
		and os.clock() >= getgenv().armTime3 then
			getgenv().animationDetected3 = true
		end
	end)
end

if player.Character then hookStep(player.Character) end
player.CharacterAdded:Connect(hookStep)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.One then return end
	if getgenv().distance3 <= 0 then return end
	if getgenv().moving3 or getgenv().boostCooldown3 then return end

	getgenv().armTime3 = os.clock()
	getgenv().animationDetected3 = false
	local currentDistance = getgenv().distance3

	task.delay(1.275, function()
		if not getgenv().animationDetected3 or getgenv().boostCooldown3 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving3 = true
		getgenv().boostCooldown3 = true

		local speed = currentDistance / duration3
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z).Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving3 = false
				task.delay(boostCooldownTime3, function()
					getgenv().boostCooldown3 = false
				end)
			end
		end)
	end)
end)


getgenv().distance4 = 0
local duration4 = 0.55
local boostCooldownTime4 = 0.15
local kaiser_anim = "rbxassetid://110660551661470"

getgenv().moving4 = false
getgenv().boostCooldown4 = false
getgenv().animationDetected4 = false
getgenv().armTime4 = 0

maintab:Slider("Off The Ball Distance", 0, 0, 200, 1, function(v)
	getgenv().distance4 = v
end)

local function hookKaiser(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and track.Animation.AnimationId == kaiser_anim
		and os.clock() >= getgenv().armTime4 then
			getgenv().animationDetected4 = true
		end
	end)
end

if player.Character then hookKaiser(player.Character) end
player.CharacterAdded:Connect(hookKaiser)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Three then return end
	if getgenv().distance4 <= 0 then return end
	if getgenv().moving4 or getgenv().boostCooldown4 then return end

	getgenv().armTime4 = os.clock()
	getgenv().animationDetected4 = false
	local currentDistance = getgenv().distance4

	task.delay(0.2, function()
		if not getgenv().animationDetected4 or getgenv().boostCooldown4 then return end

		local character = player.Character
		if not character then return end

		local hrp = character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving4 = true
		getgenv().boostCooldown4 = true

		local speed = currentDistance / duration4
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z)
			if dir.Magnitude == 0 then dir = Vector3.new(0, 0, 1) end
			dir = dir.Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving4 = false
				task.delay(boostCooldownTime4, function()
					getgenv().boostCooldown4 = false
				end)
			end
		end)
	end)
end)

getgenv().distance5 = 0
local duration5 = 1
local boostCooldownTime5 = 0.15
local occlusion_anim = "rbxassetid://116181317759538"

getgenv().moving5 = false
getgenv().boostCooldown5 = false
getgenv().animationDetected5 = false
getgenv().armTime5 = 0

maintab:Slider("Occlusion Break Distance", 0, 0, 200, 1, function(v)
	getgenv().distance5 = v
end)

local function hookOcclusion(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and track.Animation.AnimationId == occlusion_anim
		and os.clock() >= getgenv().armTime5 then
			getgenv().animationDetected5 = true
		end
	end)
end

if player.Character then hookOcclusion(player.Character) end
player.CharacterAdded:Connect(hookOcclusion)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.One then return end
	if getgenv().distance5 <= 0 then return end
	if getgenv().moving5 or getgenv().boostCooldown5 then return end

	getgenv().armTime5 = os.clock()
	getgenv().animationDetected5 = false
	local currentDistance = getgenv().distance5

	task.delay(0.2, function()
		if not getgenv().animationDetected5 or getgenv().boostCooldown5 then return end

		local character = player.Character
		if not character then return end

		local hrp = character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving5 = true
		getgenv().boostCooldown5 = true

		local speed = currentDistance / duration5
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z)
			if dir.Magnitude == 0 then dir = Vector3.new(0, 0, 1) end
			dir = dir.Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving5 = false
				task.delay(boostCooldownTime5, function()
					getgenv().boostCooldown5 = false
				end)
			end
		end)
	end)
end)

getgenv().distance6 = 0
local duration6 = 0.35
local boostCooldownTime6 = 0.15
local diving_anim = "rbxassetid://91506202951715"

getgenv().moving6 = false
getgenv().boostCooldown6 = false
getgenv().animationDetected6 = false
getgenv().armTime6 = 0

maintab:Slider("Diving Header Distance", 0, 0, 125, 1, function(v)
	getgenv().distance6 = v
end)

local function hookDiving(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and track.Animation.AnimationId == diving_anim
		and os.clock() >= getgenv().armTime6 then
			getgenv().animationDetected6 = true
		end
	end)
end

if player.Character then hookDiving(player.Character) end
player.CharacterAdded:Connect(hookDiving)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Two then return end
	if getgenv().distance6 <= 0 then return end
	if getgenv().moving6 or getgenv().boostCooldown6 then return end

	getgenv().armTime6 = os.clock()
	getgenv().animationDetected6 = false
	local currentDistance = getgenv().distance6

	task.delay(0.4, function()
		if not getgenv().animationDetected6 or getgenv().boostCooldown6 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving6 = true
		getgenv().boostCooldown6 = true

		local speed = currentDistance / duration6
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z)
			if dir.Magnitude == 0 then dir = Vector3.new(0, 0, 1) end
			dir = dir.Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving6 = false
				task.delay(boostCooldownTime6, function()
					getgenv().boostCooldown6 = false
				end)
			end
		end)
	end)
end)

getgenv().distance8 = 0
local duration8 = 0.35
local boostCooldownTime8 = 0.15
local mach_anim1 = "rbxassetid://133945265328817"
local mach_anim2 = "rbxassetid://88448030655006"

getgenv().moving8 = false
getgenv().boostCooldown8 = false
getgenv().animationDetected8 = false
getgenv().armTime8 = 0

maintab:Slider("Mach Cut-In Distance", 0, 0, 200, 1, function(v)
	getgenv().distance8 = v
end)

local function hookMach(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and (track.Animation.AnimationId == mach_anim1
		     or track.Animation.AnimationId == mach_anim2)
		and os.clock() >= getgenv().armTime8 then
			getgenv().animationDetected8 = true
		end
	end)
end

if player.Character then hookMach(player.Character) end
player.CharacterAdded:Connect(hookMach)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.One then return end
	if getgenv().distance8 <= 0 then return end
	if getgenv().moving8 or getgenv().boostCooldown8 then return end

	getgenv().armTime8 = os.clock()
	getgenv().animationDetected8 = false
	local currentDistance = getgenv().distance8

	task.delay(0.5, function()
		if not getgenv().animationDetected8 or getgenv().boostCooldown8 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving8 = true
		getgenv().boostCooldown8 = true

		local speed = currentDistance / duration8
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z)
			if dir.Magnitude == 0 then dir = Vector3.new(0, 0, 1) end
			dir = dir.Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving8 = false
				task.delay(boostCooldownTime8, function()
					getgenv().boostCooldown8 = false
				end)
			end
		end)
	end)
end)

getgenv().distance7 = 0
local duration7 = 0.2
local boostCooldownTime7 = 0.15
local reflex_anim = "rbxassetid://113088324958896"

getgenv().moving7 = false
getgenv().boostCooldown7 = false
getgenv().animationDetected7 = false
getgenv().armTime7 = 0

maintab:Slider("Reflex Tackle Distance", 0, 0, 125, 1, function(v)
	getgenv().distance7 = v
end)

local function hookReflex(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and track.Animation.AnimationId == reflex_anim
		and os.clock() >= getgenv().armTime7 then
			getgenv().animationDetected7 = true
		end
	end)
end

if player.Character then hookReflex(player.Character) end
player.CharacterAdded:Connect(hookReflex)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Two then return end
	if getgenv().distance7 <= 0 then return end
	if getgenv().moving7 or getgenv().boostCooldown7 then return end

	getgenv().armTime7 = os.clock()
	getgenv().animationDetected7 = false
	local currentDistance = getgenv().distance7

	task.delay(0.1, function()
		if not getgenv().animationDetected7 or getgenv().boostCooldown7 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving7 = true
		getgenv().boostCooldown7 = true

		local speed = currentDistance / duration7
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z)
			if dir.Magnitude == 0 then dir = Vector3.new(0, 0, 1) end
			dir = dir.Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving7 = false
				task.delay(boostCooldownTime7, function()
					getgenv().boostCooldown7 = false
				end)
			end
		end)
	end)
end)

getgenv().distance9 = 0
local duration9 = 1.15
local boostCooldownTime9 = 0.15
local speed_anim1 = "rbxassetid://70397727954557"
local speed_anim2 = "rbxassetid://131196726012273"

getgenv().moving9 = false
getgenv().boostCooldown9 = false
getgenv().animationDetected9 = false
getgenv().armTime9 = 0

maintab:Slider("Speed Dribble Distance", 0, 0, 200, 1, function(v)
	getgenv().distance9 = v
end)

local function hookSpeed(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and (track.Animation.AnimationId == speed_anim1
		     or track.Animation.AnimationId == speed_anim2)
		and os.clock() >= getgenv().armTime9 then
			getgenv().animationDetected9 = true
		end
	end)
end

if player.Character then hookSpeed(player.Character) end
player.CharacterAdded:Connect(hookSpeed)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Three then return end
	if getgenv().distance9 <= 0 then return end
	if getgenv().moving9 or getgenv().boostCooldown9 then return end

	getgenv().armTime9 = os.clock()
	getgenv().animationDetected9 = false
	local currentDistance = getgenv().distance9

	task.delay(0.2, function()
		if not getgenv().animationDetected9 or getgenv().boostCooldown9 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving9 = true
		getgenv().boostCooldown9 = true

		local speed = currentDistance / duration9
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z)
			if dir.Magnitude == 0 then dir = Vector3.new(0, 0, 1) end
			dir = dir.Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving9 = false
				task.delay(boostCooldownTime9, function()
					getgenv().boostCooldown9 = false
				end)
			end
		end)
	end)
end)

getgenv().distance10 = 0
local duration10 = 1
local boostCooldownTime10 = 0.1
local cut_anim1 = "rbxassetid://133384553147918"
local cut_anim2 = "rbxassetid://128936529440509"

getgenv().moving10 = false
getgenv().boostCooldown10 = false
getgenv().animationDetected10 = false
getgenv().armTime10 = 0

maintab:Slider("Cut In Distance", 0, 0, 200, 1, function(v)
	getgenv().distance10 = v
end)

local function hookCut(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and (track.Animation.AnimationId == cut_anim1
		     or track.Animation.AnimationId == cut_anim2)
		and os.clock() >= getgenv().armTime10 then
			getgenv().animationDetected10 = true
		end
	end)
end

if player.Character then hookCut(player.Character) end
player.CharacterAdded:Connect(hookCut)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Two then return end
	if getgenv().distance10 <= 0 then return end
	if getgenv().moving10 or getgenv().boostCooldown10 then return end

	getgenv().armTime10 = os.clock()
	getgenv().animationDetected10 = false
	local currentDistance = getgenv().distance10

	task.delay(0.2, function()
		if not getgenv().animationDetected10 or getgenv().boostCooldown10 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving10 = true
		getgenv().boostCooldown10 = true

		local speed = currentDistance / duration10
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z)
			if dir.Magnitude == 0 then dir = Vector3.new(0, 0, 1) end
			dir = dir.Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving10 = false
				task.delay(boostCooldownTime10, function()
					getgenv().boostCooldown10 = false
				end)
			end
		end)
	end)
end)

maintab2:Label("Auto Activate: Activates The Move When Ball Within Range.")

local autoActivateDistance = 10
local autoActivateToggle = false
local autoActivateMove = 1
local autoActivatedb = true

maintab2:Textbox("Auto Activate Move Number", "Example: 1, 2, 3, 4, 5", function(v)
    local nsdv = tonumber(v)
    if nsdv and nsdv <= 5 and nsdv > 0 then
        print("updated to " .. nsdv)
        autoActivateMove = nsdv
    end
end)

maintab2:Slider("Auto Activate Distance", 10, 3, 70, 0.5, function(v)
    autoActivateDistance = v
end)

maintab2:Toggle("Auto Activate Toggle", "Hold The Right Mouse Button To Have It On", function(v)
    autoActivateToggle = not autoActivateToggle
end)

game.UserInputService.InputBegan:Connect(function(input, bg)
    if bg then return end
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        autoActivatedb = false
    end
end)

game.UserInputService.InputEnded:Connect(function(input, bg)
    if bg then return end
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        autoActivatedb = true
    end
end)

game:GetService("RunService").RenderStepped:Connect(function()
    if not autoActivateToggle then return end

    local char = game.Players.LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local playerPos = hrp.Position
    
    if game.Workspace.Terrain:FindFirstChild("Ball") then
        local ballPos = game.Workspace.Terrain:FindFirstChild("Ball").Position
        local distance = (playerPos - ballPos).Magnitude

        if distance <= autoActivateDistance and not autoActivatedb then
            local args = {
                buffer.fromstring(buffers["base"]),
                {
                    { "skill" .. autoActivateMove }
                }
            }

            game.ReplicatedStorage:WaitForChild("ByteNetReliable"):FireServer(unpack(args))

            print("tried")
        end
    end
end)

maintab2:Label("Auto Line Ups: Helps You Aim At Certain Areas.")

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera

local character = player.Character
local hrp = character and character:FindFirstChild("HumanoidRootPart")

local padCount = 0
local targetCount = 0

local holdingRMB = false
local camLockConnection = nil
local activeTarget = nil

local function updateCharacterRefs(char)
	character = char
	hrp = character:WaitForChild("HumanoidRootPart")
end

if player.Character then
	updateCharacterRefs(player.Character)
end

player.CharacterAdded:Connect(updateCharacterRefs)

local function pad(pos, color)
	padCount += 1
	local p = Instance.new("Part")
	p.Name = "pad" .. padCount
	p.Size = Vector3.new(5, 5, 5)
	p.Position = pos
	p.Transparency = 0.65
	p.Anchored = true
	p.CanCollide = false
	p.Color = color
	p.Material = Enum.Material.SmoothPlastic
	p.Parent = Workspace
end

local function target(pos, color)
	targetCount += 1
	local t = Instance.new("Part")
	t.Name = "target" .. targetCount
	t.Shape = Enum.PartType.Ball
	t.Size = Vector3.new(6, 6, 6)
	t.Position = pos
	t.Anchored = true
	t.CanCollide = false
	t.Color = color
	t.Material = Enum.Material.Neon
	t.Parent = Workspace
end

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		holdingRMB = true
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		holdingRMB = false
		activeTarget = nil
		if camLockConnection then
			camLockConnection:Disconnect()
			camLockConnection = nil
		end
	end
end)

local function getPadUnderPlayer()
	if not hrp then return end

	local params = RaycastParams.new()
	params.FilterDescendantsInstances = {character}
	params.FilterType = Enum.RaycastFilterType.Blacklist

	local result = Workspace:Raycast(hrp.Position, Vector3.new(0, -6, 0), params)
	if result and result.Instance then
		return result.Instance.Name:match("^pad(%d+)$")
	end
end

RunService.RenderStepped:Connect(function()
	if not holdingRMB or not hrp then return end

	local padIndex = getPadUnderPlayer()
	if not padIndex then return end

	local targetPart = Workspace:FindFirstChild("target" .. padIndex)
	if not targetPart then return end

	activeTarget = targetPart

	if not camLockConnection then
		camLockConnection = RunService.RenderStepped:Connect(function()
			if not holdingRMB or not activeTarget then return end
			camera.CFrame = CFrame.new(camera.CFrame.Position, activeTarget.Position)
		end)
	end
end)


local StarterGui = game:GetService("StarterGui")

maintab2:Toggle("Sae Line Ups", "Sae's Drive Shot Line Ups.", function(s)
	if s then
		StarterGui:SetCore("SendNotification", {
			Title = "Sae Line Ups",
			Text = "Enabled.",
			Duration = 3
		})

		pad(Vector3.new(-454, -1, 1557), Color3.fromRGB(255, 0, 0))
		target(Vector3.new(-514, 54, 1693), Color3.fromRGB(255, 0, 0))

		pad(Vector3.new(-362, -1, 1675), Color3.fromRGB(0, 255, 0))
		target(Vector3.new(-424, 23, 1704), Color3.fromRGB(0, 255, 0))

		pad(Vector3.new(-535, -1, 1508), Color3.fromRGB(255, 255, 0))
		target(Vector3.new(-502, 95, 1705), Color3.fromRGB(255, 255, 0))

		pad(Vector3.new(-613, -1, 1586), Color3.fromRGB(0, 0, 255))
		target(Vector3.new(-452, 51, 1701), Color3.fromRGB(0, 0, 255))

		pad(Vector3.new(-665, -1, 994), Color3.fromRGB(255, 0, 0))
		target(Vector3.new(-585, 61, 844), Color3.fromRGB(255, 0, 0))

		pad(Vector3.new(-725, -1, 894), Color3.fromRGB(0, 255, 0))
		target(Vector3.new(-625, 39, 844), Color3.fromRGB(0, 255, 0))

		pad(Vector3.new(-462, -1, 992), Color3.fromRGB(255, 255, 0))
		target(Vector3.new(-592, 65, 844), Color3.fromRGB(255, 255, 0))

		pad(Vector3.new(-536, -1, 1050), Color3.fromRGB(0, 0, 255))
		target(Vector3.new(-541, 85, 883), Color3.fromRGB(0, 0, 255))

	else
		StarterGui:SetCore("SendNotification", {
			Title = "Sae Line Ups",
			Text = "Disabled.",
			Duration = 3
		})

		for i = 1, padCount do
			local p = Workspace:FindFirstChild("pad" .. i)
			if p then p:Destroy() end
		end

		for i = 1, targetCount do
			local t = Workspace:FindFirstChild("target" .. i)
			if t then t:Destroy() end
		end

		padCount = 0
		targetCount = 0
	end
end)

maintab2:Toggle("Kaiser Line Ups", "Kaiser's Impact Magnus Line Ups.", function(k)
	if k then
		StarterGui:SetCore("SendNotification", {
			Title = "Kaiser Line Ups",
			Text = "Enabled.",
			Duration = 3
		})

    pad(Vector3.new(-538, -1, 1097), Color3.fromRGB(255, 0, 0))
    target(Vector3.new(-526, 121, 844), Color3.fromRGB(255, 0, 0))

    pad(Vector3.new(-414, -1, 1049), Color3.fromRGB(0, 255, 0))
    target(Vector3.new(-485, 84, 843), Color3.fromRGB(0, 255, 0))

    pad(Vector3.new(-304, -1, 896), Color3.fromRGB(255, 255, 0))
    target(Vector3.new(-418, 48, 849), Color3.fromRGB(255, 255, 0))

    pad(Vector3.new(-327, -1, 843), Color3.fromRGB(0, 0, 255))
    target(Vector3.new(-443, 38, 816), Color3.fromRGB(0, 0, 255))

    pad(Vector3.new(-495, -1, 945), Color3.fromRGB(255, 0, 255))
    target(Vector3.new(-510, 19, 841), Color3.fromRGB(255, 0, 255))

    pad(Vector3.new(-669, -1, 976), Color3.fromRGB(255, 182, 193))
    target(Vector3.new(-447, 66, 847), Color3.fromRGB(255, 182, 193))

    pad(Vector3.new(-536, -1, 1469), Color3.fromRGB(255, 0, 0))
    target(Vector3.new(-547, 125, 1706), Color3.fromRGB(255, 0, 0))

    pad(Vector3.new(-766, -1, 1659), Color3.fromRGB(0, 255, 0))
    target(Vector3.new(-677, 34, 1697), Color3.fromRGB(0, 255, 0))

    pad(Vector3.new(-655, -1, 1504), Color3.fromRGB(255, 255, 0))
    target(Vector3.new(-588, 75, 1701), Color3.fromRGB(255, 255, 0))

    pad(Vector3.new(-747, -1, 1704), Color3.fromRGB(0, 0, 255))
    target(Vector3.new(-624, 43, 1732), Color3.fromRGB(0, 0, 255))

    pad(Vector3.new(-583, -1, 1603), Color3.fromRGB(255, 0, 255))
    target(Vector3.new(-559, 18, 1706), Color3.fromRGB(255, 0, 255))

    pad(Vector3.new(-408, -1, 1573), Color3.fromRGB(255, 182, 193))
    target(Vector3.new(-644, 70, 1705), Color3.fromRGB(255, 182, 193))

	else
		StarterGui:SetCore("SendNotification", {
			Title = "Kaiser Line Ups",
			Text = "Disabled.",
			Duration = 3
		})

		for i = 1, padCount do
			local p = Workspace:FindFirstChild("pad" .. i)
			if p then p:Destroy() end
		end

		for i = 1, targetCount do
			local t = Workspace:FindFirstChild("target" .. i)
			if t then t:Destroy() end
		end

		padCount = 0
		targetCount = 0
	end
end)

maintab2:Toggle("Yukimiya Line Ups", "Yukimiya's Gyro Shot Line Ups.", function(y)
	if y then
		StarterGui:SetCore("SendNotification", {
			Title = "Yukimiya Line Ups",
			Text = "Enabled.",
			Duration = 3
		})

    pad(Vector3.new(-539, -1, 1037), Color3.fromRGB(255, 0, 0))
    target(Vector3.new(-579, 67, 844), Color3.fromRGB(255, 0, 0))

    pad(Vector3.new(-630, -1, 966), Color3.fromRGB(0, 255, 0))
    target(Vector3.new(-543, 44, 843), Color3.fromRGB(0, 255, 0))

    pad(Vector3.new(-416, -1, 968), Color3.fromRGB(255, 255, 0))
    target(Vector3.new(-539, 54, 843), Color3.fromRGB(255, 255, 0))

    pad(Vector3.new(-432, -1, 917), Color3.fromRGB(0, 0, 255))
    target(Vector3.new(-527, 33, 843), Color3.fromRGB(0, 0, 255))

    pad(Vector3.new(-388, -1, 1008), Color3.fromRGB(255, 0, 255))
    target(Vector3.new(-634, 129, 844), Color3.fromRGB(255, 0, 255))

    pad(Vector3.new(-355, -1, 912), Color3.fromRGB(255, 182, 193))
    target(Vector3.new(-764, 140, 844), Color3.fromRGB(255, 182, 193))

    pad(Vector3.new(-681, -1, 1527), Color3.fromRGB(255, 0, 0))
    target(Vector3.new(-431, 138, 1704), Color3.fromRGB(255, 0, 0))

    pad(Vector3.new(-717, -1, 1624), Color3.fromRGB(0, 255, 0))
    target(Vector3.new(-604, 40, 1658), Color3.fromRGB(0, 255, 0))

    pad(Vector3.new(-417, -1, 1577), Color3.fromRGB(255, 255, 0))
    target(Vector3.new(-520, 43, 1705), Color3.fromRGB(255, 255, 0))

    pad(Vector3.new(-533, -1, 1505), Color3.fromRGB(0, 0, 255))
    target(Vector3.new(-499, 69, 1705), Color3.fromRGB(0, 0, 255))

    pad(Vector3.new(-600, -1, 1568), Color3.fromRGB(255, 0, 255))
    target(Vector3.new(-515, 29, 1705), Color3.fromRGB(255, 0, 255))

    pad(Vector3.new(-641, -1, 1624), Color3.fromRGB(255, 182, 193))
    target(Vector3.new(-540, 37, 1705), Color3.fromRGB(255, 182, 193))

	else
		StarterGui:SetCore("SendNotification", {
			Title = "Yukimiya Line Ups",
			Text = "Disabled.",
			Duration = 3
		})

		for i = 1, padCount do
			local p = Workspace:FindFirstChild("pad" .. i)
			if p then p:Destroy() end
		end

		for i = 1, targetCount do
			local t = Workspace:FindFirstChild("target" .. i)
			if t then t:Destroy() end
		end

		padCount = 0
		targetCount = 0
	end
end)

maintab2:Label("Auto Position: Instantly Picks Certain Position.")

_G.AutoToggles = _G.AutoToggles or {
	CF = false,
	GK = false,
	CFConn = nil,
	GKConn = nil
}

buffer = buffer or {
	fromstring = function(str)
		return str
	end
}

function _G.firePacketsIfNear()
	local char = game:GetService("Players").LocalPlayer.Character
	if not char then return end
	local root = char:FindFirstChild("HumanoidRootPart")
	if not root then return end

	if (root.Position - Vector3.new(-260, 4, -1474)).Magnitude <= 15 or
	   (root.Position - Vector3.new(-262, 4, -1722)).Magnitude <= 15 then
		game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\006\001\001\000A"))
		game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\006\001\001\000B"))
	end
end

function _G.fireGKPackets()
	local char = game:GetService("Players").LocalPlayer.Character
	if not char then return end
	local root = char:FindFirstChild("HumanoidRootPart")
	if not root then return end

	game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\006\005\001\000B"))
	game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\006\005\001\000A"))
end

maintab2:Toggle("Auto Pick CF", "Automatically Picks Center Field Position On Respawn Or Enable.", function()
	_G.AutoToggles.CF = not _G.AutoToggles.CF

	game:GetService("StarterGui"):SetCore("SendNotification", {
		Title = "Auto Pick CF",
		Text = _G.AutoToggles.CF and "Enabled." or "Disabled.",
		Duration = 1
	})

	if _G.AutoToggles.CF then
		_G.AutoToggles.CFConn = game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function()
			task.wait(1)
			_G.firePacketsIfNear()
		end)

		task.spawn(function()
			repeat task.wait() until game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
			_G.firePacketsIfNear()
		end)
	else
		if _G.AutoToggles.CFConn then
			_G.AutoToggles.CFConn:Disconnect()
			_G.AutoToggles.CFConn = nil
		end
	end
end)

maintab2:Toggle("Auto Pick GK", "Automatically Picks Goalkeeper Position On Respawn Or Enable.", function()
	_G.AutoToggles.GK = not _G.AutoToggles.GK

	game:GetService("StarterGui"):SetCore("SendNotification", {
		Title = "Auto Pick GK",
		Text = _G.AutoToggles.GK and "Enabled." or "Disabled.",
		Duration = 1
	})

	if _G.AutoToggles.GK then
		_G.AutoToggles.GKConn = game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function()
			task.wait(1)
			_G.fireGKPackets()
		end)

		task.spawn(function()
			repeat task.wait() until game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
			_G.fireGKPackets()
		end)
	else
		if _G.AutoToggles.GKConn then
			_G.AutoToggles.GKConn:Disconnect()
			_G.AutoToggles.GKConn = nil
		end
	end
end)

maintab2:Label("Auto Goalkeeper: Automatically Plays As GK For You.")

maintab2:Button("Celeron's Auto GK (V1, Silent.)", "Automatically Attempts To Block Shots By Opponents, Reset Or Click F4 To Disable.", function()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local plr = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local hum = char:WaitForChild("Humanoid")
local hrp = char:WaitForChild("HumanoidRootPart")

local function getBall()
	return Workspace.Terrain:FindFirstChild("Ball")
end

hum.AutoRotate = false

local look = Instance.new("AlignOrientation")
look.Mode = Enum.OrientationAlignmentMode.OneAttachment
look.Attachment0 = hrp:WaitForChild("RootAttachment")
look.Responsiveness = 1200
look.MaxTorque = math.huge
look.Enabled = false
look.Parent = hrp

local onn = true
local pause = false

local ballHolder = ReplicatedStorage.workspace.ballHolder
local lastHolder = ballHolder.Value

ballHolder.Changed:Connect(function()
	local cur = ballHolder.Value
	if lastHolder == char and cur == nil then
		pause = true
		task.delay(0.3, function()
			pause = false
		end)
	end
	lastHolder = cur
end)

local remote = ReplicatedStorage:WaitForChild("ByteNetReliable")
local map = Workspace:WaitForChild("map")
local GRAVITY = Vector3.new(0, -Workspace.Gravity, 0)

local function getTeamGoal()
	if plr.Team == game.Teams.B then
		return map.Bgoal
	elseif plr.Team == game.Teams.A then
		return map.Agoal
	end
end

local function predictGoalImpact(pos, vel, accel, goal)
	if not goal then return nil end
	local cf = goal.CFrame
	local normal = cf.LookVector
	local goalPos = cf.Position
	local rel = pos - goalPos
	local a = 0.5 * accel:Dot(normal)
	local b = vel:Dot(normal)
	local c = rel:Dot(normal)
	if math.abs(a) < 1e-6 then
		if math.abs(b) < 1e-6 then return nil end
		local t = -c / b
		return t > 0 and t or nil
	end
	local disc = b*b - 4*a*c
	if disc < 0 then return nil end
	local sqrtDisc = math.sqrt(disc)
	local t1 = (-b - sqrtDisc) / (2*a)
	local t2 = (-b + sqrtDisc) / (2*a)
	local t
	if t1 > 0 then t = t1 end
	if t2 > 0 and (not t or t2 < t) then t = t2 end
	if not t then return nil end
	local impactPos = pos + vel * t + 0.5 * accel * t * t
	return impactPos
end

local velSmooth = Vector3.zero
local lastVel = Vector3.zero

local conn
conn = RunService.RenderStepped:Connect(function(dt)
	if not onn then
		conn:Disconnect()
		return
	end
	local ball = getBall()
	if not ball or plr.Team == game.Teams.lobby or pause then
		look.Enabled = false
		return
	end

	local rawVel = ball.AssemblyLinearVelocity
	velSmooth = velSmooth:Lerp(rawVel, math.clamp(dt * 15, 0, 1))
	local accel = (velSmooth - lastVel) / math.max(dt, 1/240)
	lastVel = velSmooth

	local goal = getTeamGoal()
	local predictedPos = nil
	local impactTime = predictGoalImpact(ball.Position, velSmooth, accel + GRAVITY, goal)
	if impactTime then
		predictedPos = ball.Position + velSmooth * impactTime + 0.5 * (accel + GRAVITY) * impactTime * impactTime
	else
		predictedPos = ball.Position + velSmooth * 0.25 + 0.5 * GRAVITY * 0.25^2
	end

	look.Enabled = true
	look.CFrame = CFrame.lookAt(hrp.Position, Vector3.new(predictedPos.X, hrp.Position.Y, predictedPos.Z))

	local dist = (hrp.Position - ball.Position).Magnitude

	local jumpTriggered = false
	local steps = 20
	for i = 0, steps do
		local t = i / steps * math.min(0.5, dist/60)
		local point = ball.Position + velSmooth * t + 0.5 * (accel + GRAVITY) * t * t
		if (point.Y > hrp.Position.Y) and ((point - hrp.Position).Magnitude <= 65) then
			jumpTriggered = true
			break
		end
	end

	if jumpTriggered then
		hum.Jump = true
		local moveDir = (Vector3.new(predictedPos.X, hrp.Position.Y, predictedPos.Z) - hrp.Position).Unit
		hrp.Velocity = moveDir * 90 + Vector3.new(0, hrp.Velocity.Y, 0)
	end

	if dist <= 65 then
		remote:FireServer(buffer.fromstring(buffers["base"]), {{ "tackle" }})
	end
end)

local disable
disable = UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.F4 then
		onn = false
		look:Destroy()
		disable:Disconnect()
		conn:Disconnect()
	end
end)

repeat task.wait() until hum.Health <= 0 or plr.Team == game.Teams.lobby
onn = false
look:Destroy()
disable:Disconnect()
conn:Disconnect()
end)

maintab2:Button("Celeron's Auto GK (V2, Semi-Blatant.)", "Automatically Attempts To Block Shots By Opponents, Reset Or Click F4 To Disable.", function()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local plr = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local hum = char:WaitForChild("Humanoid")
local hrp = char:WaitForChild("HumanoidRootPart")

local function getBall()
	return Workspace.Terrain:FindFirstChild("Ball")
end

hum.AutoRotate = false

local look = Instance.new("AlignOrientation")
look.Mode = Enum.OrientationAlignmentMode.OneAttachment
look.Attachment0 = hrp:WaitForChild("RootAttachment")
look.Responsiveness = 1200
look.MaxTorque = math.huge
look.Enabled = false
look.Parent = hrp

local onn = true
local pause = false

local ballHolder = ReplicatedStorage.workspace.ballHolder
local lastHolder = ballHolder.Value

ballHolder.Changed:Connect(function()
	local cur = ballHolder.Value
	if lastHolder == char and cur == nil then
		pause = true
		task.delay(0.3, function()
			pause = false
		end)
	end
	lastHolder = cur
end)

local remote = ReplicatedStorage:WaitForChild("ByteNetReliable")
local map = Workspace:WaitForChild("map")
local GRAVITY = Vector3.new(0, -Workspace.Gravity, 0)

local function getTeamGoal()
	if plr.Team == game.Teams.B then
		return map.Bgoal
	elseif plr.Team == game.Teams.A then
		return map.Agoal
	end
end

local function predictGoalImpact(pos, vel, accel, goal)
	if not goal then return nil end
	local cf = goal.CFrame
	local normal = cf.LookVector
	local goalPos = cf.Position
	local rel = pos - goalPos
	local a = 0.5 * accel:Dot(normal)
	local b = vel:Dot(normal)
	local c = rel:Dot(normal)
	if math.abs(a) < 1e-6 then
		if math.abs(b) < 1e-6 then return nil end
		local t = -c / b
		return t > 0 and t or nil
	end
	local disc = b*b - 4*a*c
	if disc < 0 then return nil end
	local sqrtDisc = math.sqrt(disc)
	local t1 = (-b - sqrtDisc) / (2*a)
	local t2 = (-b + sqrtDisc) / (2*a)
	local t
	if t1 > 0 then t = t1 end
	if t2 > 0 and (not t or t2 < t) then t = t2 end
	if not t then return nil end
	local impactPos = pos + vel * t + 0.5 * accel * t * t
	return impactPos
end

local velSmooth = Vector3.zero
local lastVel = Vector3.zero

local conn
conn = RunService.RenderStepped:Connect(function(dt)
	if not onn then
		conn:Disconnect()
		return
	end

	local ball = getBall()
	if not ball or plr.Team == game.Teams.lobby or pause then
		look.Enabled = false
		return
	end

	local rawVel = ball.AssemblyLinearVelocity
	velSmooth = velSmooth:Lerp(rawVel, math.clamp(dt * 15, 0, 1))
	local accel = (velSmooth - lastVel) / math.max(dt, 1/240)
	lastVel = velSmooth

	local goal = getTeamGoal()
	local impactTime = predictGoalImpact(ball.Position, velSmooth, accel + GRAVITY, goal)

	local predictedPos
	if impactTime then
		predictedPos = ball.Position + velSmooth * impactTime + 0.5 * (accel + GRAVITY) * impactTime * impactTime
	else
		predictedPos = ball.Position + velSmooth * 0.25 + 0.5 * GRAVITY * 0.25^2
	end

	look.Enabled = true
	look.CFrame = CFrame.lookAt(
		hrp.Position,
		Vector3.new(predictedPos.X, hrp.Position.Y, predictedPos.Z)
	)

	local dist = (hrp.Position - ball.Position).Magnitude

	if dist <= 14.5 then
		remote:FireServer(buffer.fromstring(buffers["grabball"]))
	end

	local jumpTriggered = false
	local steps = 20
	for i = 0, steps do
		local t = i / steps * math.min(0.5, dist / 60)
		local point = ball.Position + velSmooth * t + 0.5 * (accel + GRAVITY) * t * t
		if point.Y > hrp.Position.Y and (point - hrp.Position).Magnitude <= 65 then
			jumpTriggered = true
			break
		end
	end

	if jumpTriggered then
		hum.Jump = true
		local moveDir = (Vector3.new(predictedPos.X, hrp.Position.Y, predictedPos.Z) - hrp.Position).Unit
		hrp.Velocity = moveDir * 90 + Vector3.new(0, hrp.Velocity.Y, 0)
	end

	if dist <= 65 then
		remote:FireServer(buffer.fromstring(buffers["base"]), {{ "tackle" }})
	end
end)

local disable
disable = UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.F4 then
		onn = false
		look:Destroy()
		disable:Disconnect()
		conn:Disconnect()
	end
end)

repeat task.wait() until hum.Health <= 0 or plr.Team == game.Teams.lobby
onn = false
look:Destroy()
disable:Disconnect()
conn:Disconnect()
end)

maintab2:Button("Daffy's Auto GK", "Automatically Attempts To Block Shots By Opponents, Reset Or Click F4 To Disable.", function()
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local plr = Players.LocalPlayer
local char = plr.Character or plr.CharacterAdded:Wait()
local cam = workspace.CurrentCamera
local hum = char:WaitForChild("Humanoid")
local hrp = char:WaitForChild("HumanoidRootPart")

local originalCamType = cam.CameraType
local originalCamCFrame = cam.CFrame

local guii = Instance.new("ScreenGui")
guii.Parent = plr.PlayerGui

local cambu = Instance.new("TextButton")
cambu.Text = "Camera Mode"
cambu.Size = UDim2.new(0.159,0,0.109,0)
cambu.Position = UDim2.new(0.317,0,0.444,0)
cambu.TextScaled = true
cambu.Parent = guii

local gerg = Instance.new("TextButton")
gerg.Text = "Body Mode"
gerg.Size = UDim2.new(0.159,0,0.109,0)
gerg.Position = UDim2.new(0.524,0,0.444,0)
gerg.TextScaled = true
gerg.Parent = guii

local dot = Instance.new("Frame")
dot.Size = UDim2.new(0.012,0,0.025,0)
dot.Position = UDim2.new(0.988,0,0.975,0)
dot.BackgroundColor3 = Color3.fromRGB(0,255,0)
dot.BorderSizePixel = 0
dot.Parent = guii

local buffers = {}
loadstring(game:HttpGet("https://pastebin.com/raw/8XJh7dzh"))()
repeat task.wait() until game.Lighting:FindFirstChild("BUFFERSTRINGS")
for _,v in ipairs(game.Lighting.BUFFERSTRINGS:GetChildren()) do
	buffers[v.Name] = v.Value
end
game.Lighting.BUFFERSTRINGS:Destroy()

local kind = ""
cambu.MouseButton1Up:Connect(function()
	kind = "cam"
end)
gerg.MouseButton1Up:Connect(function()
	kind = "body"
end)

repeat task.wait() until kind ~= ""
cambu:Destroy()
gerg:Destroy()

local function getBall()
	return workspace.Terrain:FindFirstChild("Ball")
end

local align
if kind == "body" then
	hum.AutoRotate = false
	align = Instance.new("AlignOrientation")
	align.Mode = Enum.OrientationAlignmentMode.OneAttachment
	align.Attachment0 = hrp:WaitForChild("RootAttachment")
	align.Responsiveness = 300
	align.MaxTorque = math.huge
	align.Enabled = false
	align.Parent = hrp
end

local onn = true
local pause = false

local ballHolder = ReplicatedStorage.workspace.ballHolder
local lastHolder = ballHolder.Value

ballHolder.Changed:Connect(function()
	local cur = ballHolder.Value
	if lastHolder == char and cur == nil then
		pause = true
		task.delay(0.7, function()
			pause = false
		end)
	end
	lastHolder = cur
end)

local remote = ReplicatedStorage:WaitForChild("ByteNetReliable")

local function cleanup()
	onn = false

	if align then
		align:Destroy()
	end

	cam.CameraType = originalCamType
	cam.CFrame = originalCamCFrame

	if guii then
		guii:Destroy()
	end
end

local con
con = RunService.RenderStepped:Connect(function()
	if not onn then
		con:Disconnect()
		return
	end

	local ball = getBall()
	if not ball or plr.Team == game.Teams.lobby or pause then
		if align then align.Enabled = false end
		return
	end

	if kind == "cam" then
		cam.CameraType = Enum.CameraType.Scriptable
		cam.CFrame = CFrame.lookAt(cam.CFrame.Position, ball.Position)

	elseif kind == "body" then
		align.Enabled = true
		local dir = ball.Position - hrp.Position
		dir = Vector3.new(dir.X, 0, dir.Z)
		if dir.Magnitude > 0.01 then
			align.CFrame = CFrame.lookAt(Vector3.zero, dir)
		end
	end

	local dist = (hrp.Position - ball.Position).Magnitude
	if dist <= 60 then
		if ball.Position.Y >= hrp.Position.Y + 6 then
			hum.Jump = true
		else
			hum.Jump = false
		end

		remote:FireServer(
			buffer.fromstring(buffers.base),
			{
				{ "tackle" }
			}
		)
	end
end)

local kill
kill = UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if input.KeyCode == Enum.KeyCode.F4 then
		cleanup()
		kill:Disconnect()
		con:Disconnect()
	end
end)

repeat task.wait() until hum.Health <= 0 or plr.Team == game.Teams.lobby
cleanup()
kill:Disconnect()
con:Disconnect()
end)

maintab2:Label("Other Features: Self Explanatory, Other Silent Features.")

local remote = game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable")
local UIS = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")

local airDribbleEnabled = false

maintab2:Toggle("Air Dribble (Bind: LeftAlt)", "Kicks The Ball Forward Infront Of You And Up On LeftAlt Click.", function()
    airDribbleEnabled = not airDribbleEnabled
    StarterGui:SetCore("SendNotification", {
        Title = "Air Dribble",
        Text = airDribbleEnabled and "Enabled." or "Disabled.",
        Duration = 2
    })
end)

UIS.InputBegan:Connect(function(input, gp)
    if gp or input.KeyCode ~= Enum.KeyCode.LeftAlt then return end
    if not airDribbleEnabled then return end

    local char = game.Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not (hum and root) then return end

    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://76587445975710"
    local track = hum:LoadAnimation(anim)
    track:Play()

    local dir = root.CFrame.LookVector
    local kickVec = vector.create(dir.X * 0.75, 0.65, dir.Z * 0.75)

    remote:FireServer(buffer.fromstring(buffers["base"]), { { "kick", 28, false, kickVec } })
end)

maintab2:Toggle("Auto QuickTimeEvent", "Automatically Does QuickTimeEvents, How Else Can I Explain It?", function()
local runService = game:GetService("RunService")
local players = game:GetService("Players")
local virtualInputManager = game:GetService("VirtualInputManager")
local starterGui = game:GetService("StarterGui")
local player = players.LocalPlayer

_G.QuickTimeEvent = not _G.QuickTimeEvent

local function sendNotification(status)
    if not _G.suppressNotifs then
        starterGui:SetCore("SendNotification", {
            Title = "QuickTimeEvent",
            Text = status,
            Duration = 1
        })
    end
end

local function convertNumberToKeyText(text)
    local numberMap = {
        ["1"] = "One", ["2"] = "Two", ["3"] = "Three", ["4"] = "Four", ["5"] = "Five",
        ["6"] = "Six", ["7"] = "Seven", ["8"] = "Eight", ["9"] = "Nine", ["0"] = "Zero"
    }
    return numberMap[text] or text
end

local function isShadeOfGreen(color)
    return color.G > color.R and color.G > color.B
end

local function checkQTE()
    if _G.QuickTimeEvent and player and player:FindFirstChild("PlayerGui") then
        local qteGui = player.PlayerGui:FindFirstChild("Qte")
        if qteGui and qteGui:FindFirstChild("QTE") then
            for _, descendant in ipairs(qteGui.QTE:GetDescendants()) do
                if descendant:IsA("Frame") or descendant:IsA("TextLabel") then
                    if isShadeOfGreen(descendant.BackgroundColor3) then
                        local textLabel = qteGui.QTE:FindFirstChild("TextLabel")
                        if textLabel then
                            local keyText = convertNumberToKeyText(textLabel.Text)
                            local keyCode = Enum.KeyCode[keyText]
                            if keyCode then
                                virtualInputManager:SendKeyEvent(true, keyCode, false, game)
                                virtualInputManager:SendKeyEvent(false, keyCode, false, game)
                            end
                        end
                        break
                    end
                end
            end
        end
    end
end

runService.RenderStepped:Connect(checkQTE)
sendNotification(_G.QuickTimeEvent and "Enabled." or "Disabled.")
end)

maintab2:Toggle("Auto Formless (Bind: Y)", "Shidou Only Formless Macro.", function()
	local UIS = game:GetService("UserInputService")
	local Players = game:GetService("Players")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local StarterGui = game:GetService("StarterGui")
	local Camera = workspace.CurrentCamera

	local LP = Players.LocalPlayer
	local ByteNetReliable = ReplicatedStorage:WaitForChild("ByteNetReliable")

	_G.autoFormlessEnabled = not (_G.autoFormlessEnabled or false)
	if not _G.suppressNotifs then
		StarterGui:SetCore("SendNotification", {
			Title = "Auto Formless",
			Text = _G.autoFormlessEnabled and "Enabled." or "Disabled.",
			Duration = 2
		})
	end

	if not _G.autoFormlessEnabled then return end

	UIS.InputBegan:Connect(function(input, gp)
		if not _G.autoFormlessEnabled or gp or input.KeyCode ~= Enum.KeyCode.Y or UIS.MouseBehavior ~= Enum.MouseBehavior.LockCenter then return end

		local char = LP.Character
		local hrp = char and char:FindFirstChild("HumanoidRootPart")
		local hum = char and char:FindFirstChildOfClass("Humanoid")
		if not hrp or not hum then return end

		hum.AutoRotate = false

		local camType = Camera.CameraType
		local camSubject = Camera.CameraSubject

		local camCF = Camera.CFrame
		local flipped = camCF * CFrame.Angles(0, math.rad(180), 0)

		Camera.CameraType = Enum.CameraType.Scriptable
		Camera.CFrame = flipped

		task.delay(0.1, function()
			if LP.Character and LP.Character:FindFirstChildOfClass("Humanoid") then
				Camera.CameraSubject = LP.Character:FindFirstChildOfClass("Humanoid")
				Camera.CameraType = Enum.CameraType.Custom
			else
				Camera.CameraSubject = camSubject
				Camera.CameraType = camType
			end
			hum.AutoRotate = true
		end)

		task.wait(0.15)

		local anim = Instance.new("Animation")
		anim.AnimationId = "rbxassetid://76587445975710"
		local track = hum:LoadAnimation(anim)
		track:Play()

		local dir = hrp.CFrame.LookVector
		local kickVec = vector.create(dir.X * 0.5, 1, dir.Z * 0.5)

		remote:FireServer(buffer.fromstring(buffers["base"]), { { "kick", 25, false, kickVec } })

		ByteNetReliable:FireServer(
			buffer.fromstring(buffers["base"]),
			{ { "skill1" } }
		)
	end)
end)

_G.nocutscene = false

maintab2:Toggle("No Cutscene", "Shitty Feature For Right Now That Disables Cutscenes.", function()
	_G.nocutscene = not _G.nocutscene

	local StarterGui = game:GetService("StarterGui")
	local SoundService = game:GetService("SoundService")
	local tempFolder = SoundService:FindFirstChild("celerontemp") or Instance.new("Folder", SoundService)
	tempFolder.Name = "celerontemp"

	local crowdSound = SoundService:FindFirstChild("football-crowd-3-69245") or tempFolder:FindFirstChild("football-crowd-3-69245")

	StarterGui:SetCore("SendNotification", {
		Title = "No Cutscene",
		Text = _G.nocutscene and "Enabled." or "Disabled.",
		Duration = 1
	})

	if _G.nocutscene then
		if crowdSound and crowdSound:IsDescendantOf(SoundService) then
			local clone = crowdSound:Clone()
			clone.Parent = tempFolder
			crowdSound:Stop()
			crowdSound:Destroy()
		end
	else
		local stored = tempFolder:FindFirstChild("football-crowd-3-69245")
		if stored then
			stored.Parent = SoundService
			stored:Play()
		end
	end
end)

local iframeIndicatorEnabled = false
local activeDots = {}
local dotSize = UDim2.new(0, 6, 0, 6)
local offset = Vector3.new(0, 3, 0)
local updateInterval = 0.2

maintab2:Toggle("IFrame Indicator", "Shows The I-Frame Status Of All Players. (Green = Off, Red = On.)", function()
	iframeIndicatorEnabled = not iframeIndicatorEnabled

	local StarterGui = game:GetService("StarterGui")
	StarterGui:SetCore("SendNotification", {
		Title = "IFrame Indicator",
		Text = iframeIndicatorEnabled and "Enabled." or "Disabled.",
		Duration = 3
	})

	local charactersFolder = workspace:FindFirstChild("characters")
	if not charactersFolder then return end

	local function createDot(char)
		if activeDots[char] then return end
		local hrp = char:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		local gui = Instance.new("BillboardGui")
		gui.Name = "IframeDot"
		gui.Size = UDim2.new(0, 12, 0, 12)
		gui.StudsOffset = offset
		gui.AlwaysOnTop = true
		gui.Adornee = hrp
		gui.Parent = hrp

		local dot = Instance.new("Frame")
		dot.Size = dotSize
		dot.Position = UDim2.new(0.5, -3, 0.5, -3)
		dot.BackgroundColor3 = Color3.fromRGB(128, 128, 128)
		dot.BorderSizePixel = 0
		dot.BackgroundTransparency = 0
		dot.Parent = gui

		activeDots[char] = dot
	end

	local function updateDot(char, dot)
		local state = char:FindFirstChild("state")
		local iframe = state and state:FindFirstChild("iframe")
		if iframe and iframe:IsA("BoolValue") then
			dot.BackgroundColor3 = iframe.Value and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(0, 255, 0)
		else
			dot.BackgroundColor3 = Color3.fromRGB(128, 128, 128)
		end
	end

	local function clearDots()
		for char, dot in pairs(activeDots) do
			if dot and dot.Parent then
				dot.Parent:Destroy()
			end
		end
		activeDots = {}
	end

	if iframeIndicatorEnabled then
		for _, char in ipairs(charactersFolder:GetChildren()) do
			createDot(char)
		end

		charactersFolder.ChildAdded:Connect(function(char)
			task.wait(0.5)
			if iframeIndicatorEnabled then
				createDot(char)
			end
		end)

		task.spawn(function()
			while iframeIndicatorEnabled do
				for char, dot in pairs(activeDots) do
					if char and dot then
						updateDot(char, dot)
					end
				end
				for _, char in ipairs(charactersFolder:GetChildren()) do
					if not activeDots[char] then
						createDot(char)
					end
				end
				task.wait(updateInterval)
			end
		end)
	else
		clearDots()
	end
end)

maintab2:Button("Fix Duplicate Ball", "I Don't Know If This Is Still An Issue But Removes Duplicate Balls If Existent.", function()
for _, obj in ipairs(workspace.Terrain:GetDescendants()) do
	if obj:IsA("MeshPart") and obj.Name == "Ball" then
		obj:Destroy()
	end
end
end)

funtab:Label("Celeron's Movesets, Recommend Using In Normal Servers.")

funtab:Button("Goku Moveset (Req. Isagi)", function()
local StarterGui = game:GetService("StarterGui")
StarterGui:SetCore("SendNotification", {
    Title = "Credits",
    Text = "brought to you by celeron!",
    Duration = 5,
    Button1 = "OK",
})
loadstring(game:HttpGet("https://raw.githubusercontent.com/ghostofcelleron/Celeron/refs/heads/main/goku%20moveset%20(azl)",true))()
end)

funtab:Button("Aizen Moveset (Req. Isagi, Early Access.)", function()
local StarterGui = game:GetService("StarterGui")
StarterGui:SetCore("SendNotification", {
    Title = "Credits",
    Text = "brought to you by celeron!",
    Duration = 5,
    Button1 = "OK",
})
loadstring(game:HttpGet("https://raw.githubusercontent.com/ghostofcelleron/Celeron/refs/heads/main/aizen%20moveset",true))()
end)

funtab:Label("Daffy's Movesets.")
funtab:Button("Ronaldo V2 (Req. Shidou)", function()
local StarterGui = game:GetService("StarterGui")
StarterGui:SetCore("SendNotification", {
    Title = "Credits",
    Text = "brought to you by daffy!",
    Duration = 5,
    Button1 = "OK",
})

local plr = game.Players.LocalPlayer
local rep = game:GetService("ReplicatedStorage")
local initialized = false
local fahh = false

local function ToggleAttachment(attachment, enabled, duration)
	if not attachment then return end
	for _, descendant in ipairs(attachment:GetDescendants()) do
		if descendant:IsA("ParticleEmitter") then
			descendant.Enabled = enabled
		end
	end
	if duration and duration > 0 then
		task.delay(duration, function()
			ToggleAttachment(attachment, false)
		end)
	end
end

local function EmitAttachment(attachment)
	if not attachment then return end
	for _, descendant in ipairs(attachment:GetDescendants()) do
		if descendant:IsA("ParticleEmitter") then
			local delayTime = descendant:GetAttribute("EmitDelay") or 0
			local count = descendant:GetAttribute("EmitCount") or 1
			if delayTime > 0 then
				task.delay(delayTime, function()
					descendant:Emit(count)
				end)
			else
				descendant:Emit(count)
			end
		end
	end
end

local function GroupWeld(model, rootPart)
	for _, part in ipairs(rootPart:GetDescendants()) do
		if part:IsA("BasePart") and model:FindFirstChild(part.Name) then
			local weld = Instance.new("Weld")
			weld.Name = "weld"
			weld.Part0 = model:FindFirstChild(part.Name)
			weld.Part1 = part
			weld.Parent = part
		end
	end
end

local function hasball()
	return plr.Character:FindFirstChild("Ball") ~= nil
end

local function BodyVelocity(part, speed, duration, startAtZero, easingInfo, delayTween, delayStart, useCustomTween)
	for _, v in pairs(part:GetChildren()) do
		if v:IsA("BodyVelocity") then
			v:Destroy()
		end
	end

	local directionProperty = delayTween or "LookVector"
	local bv = Instance.new("BodyVelocity")
	bv.MaxForce = Vector3.new(350000, 0, 350000)
	bv.Parent = part
	task.delay(duration, bv.Destroy, bv)

	local valueHolder = Instance.new("NumberValue")
	valueHolder.Value = startAtZero and 0 or speed
	valueHolder.Parent = bv

	if not useCustomTween then
		local tweenInfo = easingInfo or TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
		local goal = { Value = startAtZero and 0 or speed }
		game.TweenService:Create(valueHolder, tweenInfo, goal):Play()
	else
		task.delay(useCustomTween, function()
			local easingStyle = easingInfo or Enum.EasingStyle.Linear
			local goal = { Value = startAtZero and 0 or speed }
			local tweenInfo = TweenInfo.new(duration, easingStyle, Enum.EasingDirection.Out)
			game.TweenService:Create(valueHolder, tweenInfo, goal):Play()
		end)
	end

	if not delayStart then
		bv.Velocity = part.CFrame[directionProperty] * speed
		local connection
		connection = game["Run Service"].RenderStepped:Connect(function()
			if not bv:IsDescendantOf(game) then
				connection:Disconnect()
				return
			end
			bv.Velocity = part.CFrame[directionProperty] * valueHolder.Value
		end)
	end

	return bv, valueHolder
end

local function sfx(sound:Sound, part:Instance)
	local s = sound:Clone()
	s.Parent = part
	s:Play()
	game.Debris:AddItem(s, s.TimeLength + 20)
end

game.UserInputService.InputBegan:Connect(function(input, bg)
	if bg then return end
	local char = plr.Character
	if input.KeyCode == Enum.KeyCode.Three then
		task.spawn(function()
			char.state.stun.Value = true
			task.wait(0.03)
			char.state.stun.Value = fahh and true or false
		end)

		task.wait(0.03)

		if char.state.stun.Value or not hasball() or fahh then return end

		local root = char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart
		char.state.stun.Value = true
		local loopws = game:GetService("RunService").RenderStepped:Connect(function()
			char.Humanoid.WalkSpeed = 0
		end)
		fahh = true

		task.delay(4.6, function()
			loopws:Disconnect()
			char.Humanoid.WalkSpeed = 40
			char.state.stun.Value = false
			local cooldown = plr.PlayerGui.Hotbar.Backpack.Hotbar.skill3.Cooldown
			cooldown.Size = UDim2.new(1, 0, -1, 0)
			cooldown.Visible = true
			game.TweenService:Create(cooldown, TweenInfo.new(1, Enum.EasingStyle.Linear), {Size = UDim2.new(1, 0, 0, 0)}):Play()
			task.wait(1)
			cooldown.Visible = false
			fahh = false
		end)

		local anim = char.Humanoid:LoadAnimation(rep.Resources.ronaldo.running)
		anim:Play()

		local dribbleClone = rep.Resources.RonaldoDribble:Clone()
		GroupWeld(char, dribbleClone)
		dribbleClone.Parent = workspace.Effects
		sfx(rep.Resources.ronaldo.RonaldoDribble, root)
		game.Debris:AddItem(dribbleClone, 5)

		task.spawn(function()
			task.delay(1.5,  function() BodyVelocity(root,  40, 1   ) end)
			task.delay(1.8,  function() BodyVelocity(root, 120, 1.1 ) end)
			task.delay(2.5,  function() BodyVelocity(root,  90, 0.75) end)
			task.delay(2.9,  function() BodyVelocity(root, 100, 0.85) end)
			task.delay(3.2,  function() BodyVelocity(root, 175, 1.7 ) end)
			task.delay(3.9,  function() BodyVelocity(root,  40, 0.65) end)
		end)

		task.spawn(function()
			local attach = dribbleClone.Rig.Head["1"]
			EmitAttachment(attach)
			ToggleAttachment(attach, true, 1)
		end)

		task.delay(2.5,   function() EmitAttachment(dribbleClone.Rig.HumanoidRootPart["3"]) end)
		task.delay(2.933, function() EmitAttachment(dribbleClone.Rig.HumanoidRootPart["4"]) end)
		task.delay(3.2,   function() EmitAttachment(dribbleClone.Rig.HumanoidRootPart["3.2"]) end)
		task.delay(3.417, function() EmitAttachment(dribbleClone.Rig.HumanoidRootPart["3.5"]) end)
		task.delay(3.933, function() EmitAttachment(dribbleClone.Rig.HumanoidRootPart["5"]) end)

	elseif input.KeyCode == Enum.KeyCode.Two then
		if char.state.stun.Value or not hasball() or plr.PlayerGui.Hotbar.Backpack.Hotbar.skill2.Cooldown.Visible then return end

		local bicycle1 = Instance.new("Animation")
		bicycle1.AnimationId = "rbxassetid://126734456236034"
		local bicycle = char.Humanoid:LoadAnimation(bicycle1)
		bicycle.Priority = Enum.AnimationPriority.Action2
		bicycle:Play()

		sfx(rep.Resources.ronaldo.KICK, char.HumanoidRootPart)

		task.delay(0.8, function()
			local boom = rep.Resources.ronaldo.bicyclekick:Clone()
			boom.Parent = char.HumanoidRootPart
			boom.CFrame = char.HumanoidRootPart.CFrame * CFrame.new(0, 0, -2)
			for _, v in pairs(boom:GetDescendants()) do
				if v:IsA("ParticleEmitter") then
					v:Emit(v:GetAttribute("EmitCount"))
				end
			end
			game.Debris:AddItem(boom, 5)
		end)
	end
end)

local function load(char)
	if initialized then return end
	initialized = true

	repeat task.wait() until plr.Team ~= game.Teams.lobby
	task.wait(0.1)

	local root = char:FindFirstChild("HumanoidRootPart")
	if not root then return end

	plr.PlayerGui.Hotbar.Backpack.Hotbar.skill1.Base.Reuse.Text = ""
	plr.PlayerGui.Hotbar.Backpack.Hotbar.skill3.Base.ToolName.Text = "CR7 Dribble"
	plr.PlayerGui.Hotbar.Backpack.Hotbar.skill2.Base.ToolName.Text = "Bicycle Kick"

	rep.Resources.shidou.NEWthemes.SoundId = "rbxassetid://101265113960897"
	rep.Resources.shidou.NEWshidouUlt.AnimationId = "rbxassetid://101997402253776"
end

load(plr.Character)

plr.CharacterAdded:Connect(function(char)
	task.wait(1)
	load(char)
end)
end)

funtab:Button("Gojo Moveset (Req. Isagi.)", function()
local StarterGui = game:GetService("StarterGui")
StarterGui:SetCore("SendNotification", {
    Title = "Credits",
    Text = "brought to you by daffy!",
    Duration = 5,
    Button1 = "OK",
})
loadstring(game:HttpGet("https://pastebin.com/raw/TH8xDy9X"))()
end)

funtab:Button("Loki Moveset (Req. Isagi.)", function()
local StarterGui = game:GetService("StarterGui")
StarterGui:SetCore("SendNotification", {
    Title = "Credits",
    Text = "brought to you by daffy!",
    Duration = 5,
    Button1 = "OK",
})
loadstring(game:HttpGet("https://pastebin.com/raw/LbRRX7SK"))()
end)

funtab:Button("Lore Sae Moveset (Req. Sae.)", function()
local StarterGui = game:GetService("StarterGui")
StarterGui:SetCore("SendNotification", {
    Title = "Credits",
    Text = "brought to you by daffy!",
    Duration = 5,
    Button1 = "OK",
})
loadstring(game:HttpGet("https://pastebin.com/raw/kMQ0v88u"))()
end)

misctab:Button("Infinite Yield", function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
end)

teleporttab:Button("Spawn Area", function()
	game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-269, 4, -1599)
end)

teleporttab:Button("Middle Field", function()
	game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-540, 3, 1274)
end)

teleporttab:Button("Gallery Area", function()
	game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(109, 66, 3337)
end)

teleporttab:Button("Goal Box (A)", function()
	game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-537, 3, 1575)
end)

teleporttab:Button("Goal Box (B)", function()
	game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-534, 3, 974)
end)

misctab:Button("Upgrade UI (very cool actually)", function()
loadstring(game:HttpGet("https://pastebin.com/raw/QDNYsgxQ"))()
end)

misctab:Button("Overtime Cinematics", function()
local vals = game.ReplicatedStorage.workspace
local timer = vals.timer
local ingame = vals.roundstart

local music1Isagi = game:GetService("ReplicatedStorage").Resources.isagi["isagi themeover"]
local music2Sae = game:GetService("ReplicatedStorage").Resources.sae["sae one shot match theme"]

local gui = Instance.new("ScreenGui")
gui.ScreenInsets = Enum.ScreenInsets.None
gui.Name = "overtimethang"
gui.Parent = game.Players.LocalPlayer.PlayerGui

local image = Instance.new("ImageLabel")
image.AnchorPoint = Vector2.new(0.5, 0.5)
image.Position = UDim2.new(0.5, 0,0.5, 0)
image.Size = UDim2.new(1.2, 0,1.2, 0)
image.Image = "rbxassetid://11030033771"
image.ImageTransparency = 0.8
image.BackgroundTransparency = 1
image.Parent = gui

local overtime = false

task.spawn(function()
    while task.wait(0.05) do
        image.Visible = overtime
        
        if overtime == true then
            if game.Workspace.CurrentCamera.CameraType == Enum.CameraType.Custom then
                game.TweenService:Create(game.Workspace.CurrentCamera, TweenInfo.new(0.2), {FieldOfView = 100}):Play()
            end
            
            if image.Rotation == 0 then
                image.Rotation = 180
            else
                image.Rotation = 0
            end
        end
    end
end)

timer.Changed:Connect(function()
    if timer.Value == 0 and ingame.Value == true then
        overtime = true
        
        repeat
            music1Isagi:Play()
            for i = 1, 50 do
                task.wait(1)
                if ingame.Value == false then
                    break
                end
            end
            music2Sae:Play()
            for i = 1, 58 do
                task.wait(1)
                if ingame.Value == false then
                    break
                end
            end
        until ingame.Value == false
        
    elseif ingame.Value == false then
        
        overtime = false
        music1Isagi:Stop()
        music2Sae:Stop()
        game.TweenService:Create(game.Workspace.CurrentCamera, TweenInfo.new(0.2), {FieldOfView = 70}):Play()
        
    end
end)
end)

local Players = game:GetService("Players")
local SoundService = game:GetService("SoundService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")

local plr = Players.LocalPlayer

local bgmusicEnabled = false
local musicThread
local awakenThread
local sfx

local music = {
    "rbxassetid://126478006472705",
    "rbxassetid://138210588552041",
    "rbxassetid://137856744878500",
    "rbxassetid://97581213878614",
    "rbxassetid://71371939631022",
    "rbxassetid://119592773299545",
    "rbxassetid://134456641764445",
    "rbxassetid://100509882059819",
    "rbxassetid://128623853689708",
    "rbxassetid://70979311703713",
    "rbxassetid://92420662159372",
    "rbxassetid://97837345641106",
    "rbxassetid://102469310336986",
    "rbxassetid://101851803743361",
	"rbxassetid://88021645218929"
}

local function notify(title, text)
    StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = 3
    })
end

local function stopMusic()
    bgmusicEnabled = false

    if musicThread then
        task.cancel(musicThread)
        musicThread = nil
    end

    if awakenThread then
        task.cancel(awakenThread)
        awakenThread = nil
    end

    if sfx then
        sfx:Stop()
        sfx:Destroy()
        sfx = nil
    end

    notify("Background Music", "Disabled.")
end

local function startMusic()
    bgmusicEnabled = true

    local char = plr.Character or plr.CharacterAdded:Wait()
    local hum = char:WaitForChild("Humanoid")

    if SoundService:FindFirstChild("BGMusic") then
        SoundService.BGMusic:Destroy()
    end

    sfx = Instance.new("Sound")
    sfx.Name = "BGMusic"
    sfx.Volume = 1
    sfx.Looped = false
    sfx.SoundId = music[math.random(#music)]
    sfx.Parent = SoundService

    musicThread = task.spawn(function()
        while bgmusicEnabled and hum.Health > 0 do
            sfx:Play()
            sfx.Ended:Wait()
            if not bgmusicEnabled then break end
            sfx.SoundId = music[math.random(#music)]
        end
    end)

    awakenThread = task.spawn(function()
        while bgmusicEnabled and hum.Health > 0 do
            task.wait(0.2)
            local awaken = ReplicatedStorage.workspace.awaken.Value
            if awaken ~= nil then
                if sfx.IsPlaying then
                    sfx:Pause()
                end
            else
                if not sfx.IsPlaying then
                    sfx:Resume()
                end
            end
        end
    end)

    hum.Died:Connect(stopMusic)

    notify("Background Music", "Enabled.")
end

misctab:Toggle("Background Music", function()
    if bgmusicEnabled then
        stopMusic()
    else
        startMusic()
    end
end)

misctab:Label("Emotes.")

misctab:Toggle("Toosie Slide", function()
_G.isEnabled = _G.isEnabled or false

local animationId = "rbxassetid://95959941666543"
local soundId = "rbxassetid://1845341094"

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local animator = humanoid:FindFirstChildOfClass("Animator")

local animation = Instance.new("Animation")
animation.AnimationId = animationId

local animationTrack = animator:LoadAnimation(animation)

local sound

local function toggleState()
    _G.isEnabled = not _G.isEnabled
    
    if _G.isEnabled then
        animationTrack:Play()
        sound = Instance.new("Sound")
        sound.Name = "Toosie Slide"
        sound.SoundId = soundId
        sound.Looped = true
        sound.Parent = game.SoundService
        sound:Play()
    else
        for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
            track:Stop()
        end

        local existingSound = game.SoundService:FindFirstChild("Toosie Slide")
        if existingSound then
            existingSound:Stop()
            existingSound:Destroy()
        end
    end
end

toggleState()
end)

misctab:Toggle("Sae Pose", function()

_G.SaePose = _G.SaePose or false

local animationId = "rbxassetid://136812327261825"
local soundId = "rbxassetid://1843404009"

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local animator = humanoid:FindFirstChildOfClass("Animator")

local animation = Instance.new("Animation")
animation.AnimationId = animationId

local animationTrack = animator:LoadAnimation(animation)

local sound

local function toggleState()
    _G.SaePose = not _G.SaePose
    
    if _G.SaePose then
        animationTrack:Play()
        sound = Instance.new("Sound")
        sound.Name = "Sae Pose"
        sound.SoundId = soundId
        sound.Volume = 1
        sound.Looped = true
        sound.Parent = game.SoundService
        sound:Play()
    else
        for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
            track:Stop()
        end

        local existingSound = game.SoundService:FindFirstChild("Sae Pose")
        if existingSound then
            existingSound:Stop()
            existingSound:Destroy()
        end
    end
end

toggleState()
end)

misctab:Toggle("Assumptions", function()
_G.Assumptions = _G.Assumptions or false

local animationId = "rbxassetid://108778663919542"
local soundId = "rbxassetid://137023124734348"

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local animator = humanoid:FindFirstChildOfClass("Animator")

local animation = Instance.new("Animation")
animation.AnimationId = animationId

local animationTrack = animator:LoadAnimation(animation)

local sound

function Assumptions()
    _G.Assumptions = not _G.Assumptions
    
    if _G.Assumptions then
        animationTrack:Play()
        sound = Instance.new("Sound")
        sound.Name = "Assumptions"
        sound.SoundId = soundId
        sound.PlaybackSpeed = 0.17
        sound.Volume = 0.6
        sound.Looped = true
        sound.Parent = game.SoundService

        local eq = Instance.new("EqualizerSoundEffect")
        eq.LowGain = 10
        eq.MidGain = 0
        eq.HighGain = 4
        eq.Parent = sound

        sound:Play()
    else
        for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
            track:Stop()
        end

        local existingSound = game.SoundService:FindFirstChild("Assumptions")
        if existingSound then
            existingSound:Stop()
            existingSound:Destroy()
        end
    end
end

Assumptions()
end)

misctab:Button("Akuma Taunt", function()
local animationId = "rbxassetid://111005363990501"
local soundId = "rbxassetid://133370927301258"

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local animator = humanoid:FindFirstChildOfClass("Animator")

local animation = Instance.new("Animation")
animation.AnimationId = animationId

local animationTrack = animator:LoadAnimation(animation)

local sound = Instance.new("Sound")
sound.Name = "Akuma Taunt"
sound.SoundId = soundId
sound.Volume = 10
sound.Parent = game.SoundService

local function runOnce()
    animationTrack:Play()
    sound:Play()

    sound.Ended:Connect(function()
        sound:Destroy()
    end)

    animationTrack.Stopped:Connect(function()
        animationTrack:Stop()
    end)
end

runOnce()
end)

misctab:Button("Cartoon Fall", function()
local animationId = "rbxassetid://98064370044269"
local soundIds = { "rbxassetid://8663054927", "rbxassetid://4979513906" }

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local animator = humanoid:FindFirstChildOfClass("Animator")

local animation = Instance.new("Animation")
animation.AnimationId = animationId

local animationTrack = animator:LoadAnimation(animation)

local sound = Instance.new("Sound")
sound.Name = "Ragdoll"
sound.Volume = 10
sound.Parent = game.SoundService

local currentIndex = 1

local function playNextSound()
    if currentIndex <= #soundIds then
        sound.SoundId = soundIds[currentIndex]
        sound:Play()

        sound.Ended:Connect(function()
            currentIndex = currentIndex + 1
            playNextSound()
        end)
    else
        sound:Destroy()
    end
end
animationTrack:Play()
playNextSound()
end)

misctab:Button("Spit", function()
local animationId = "rbxassetid://97257010665720"
local soundId = "rbxassetid://18111052648"

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local animator = humanoid:FindFirstChildOfClass("Animator")

local animation = Instance.new("Animation")
animation.AnimationId = animationId

local animationTrack = animator:LoadAnimation(animation)

local sound = Instance.new("Sound")
sound.Name = "Spit"
sound.SoundId = soundId
sound.Volume = 2
sound.Parent = game.SoundService

animationTrack:Play()
sound:Play()

sound.Ended:Connect(function()
    sound:Destroy()
end)
end)

exploittab:Label("Semi-Private Server: People MAY Still Join Depending On Updates.")

exploittab:Button("Semi-Private Server Info", "This Comes With Instructions On How To Use The Feature Below.", function()
local StarterGui = game:GetService("StarterGui")

StarterGui:SetCore("SendNotification", {
    Title = "Semi-Private Server Info",
    Text = "If you end up in a server with another player, block someone.",
    Duration = 10
}) wait(0.5)
StarterGui:SetCore("SendNotification", {
    Title = "Semi-Private Server Info",
    Text = "After blocking a player in that server, run the feature to create a server again!",
    Duration = 10
})
end)

exploittab:Button("Semi-Private Server (Method: 11v11)", "This Feature Creates A Server Where You Can Farm Goals / Quests!", function()
game:GetService("TeleportService"):Teleport(85946466968831, game.Players.LocalPlayer)
end)

exploittab:Label("Instant Disconnect: Automatically Disconnects If Other Players Join.")

local limit = nil
local enabled = false

exploittab:Textbox("Instant Disconnect", "If More Than The Entered Number Of Players Join, You Disconnect.", function(v)
    local n = tonumber(v)
    if n then
        limit = n
    else
        limit = nil
    end
end)

exploittab:Toggle("Enable Instant Disconnect", "Toggles The Above Feature.", function(v)
    enabled = v
    if v then
        game.StarterGui:SetCore("SendNotification", {Title="Instant Disconnect", Text="Enabled."})
    else
        game.StarterGui:SetCore("SendNotification", {Title="Instant Disconnect", Text="Disabled."})
    end
end)

game:GetService("RunService").RenderStepped:Connect(function()
    if enabled and limit and #game.Players:GetPlayers() > limit then
        game.Players.LocalPlayer:Kick("Instant Disconnect Has Been Triggered.")
    end
end)

exploittab:Label("Goal Farming: Use At Your Own Risk, I Am Not Responsible For Bans.")

_G.GoalFarm = _G.GoalFarm or {
    Enabled = false,
    CFConn = nil,
    RenderConn = nil,
    StopAt = nil
}

buffer = buffer or {
    fromstring = function(str)
        return str
    end
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local MapFolder = workspace:WaitForChild("map")
local AGoal = MapFolder:WaitForChild("Agoal")
local BGoal = MapFolder:WaitForChild("Bgoal")
local LocalPlayer = Players.LocalPlayer

local function firePacketsIfNear()
    local char = LocalPlayer.Character
    if not char then return end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end
    if (root.Position - Vector3.new(-260, 4, -1474)).Magnitude <= 15 or
       (root.Position - Vector3.new(-262, 4, -1722)).Magnitude <= 15 then
        ReplicatedStorage:WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\006\001\001\000A"))
        ReplicatedStorage:WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\006\001\001\000B"))
    end
end

local function IsInGame()
    local LocalCharacter = LocalPlayer.Character
    if not LocalCharacter then return false end
    local StateFolder = LocalCharacter:FindFirstChild("state")
    if not StateFolder then return false end
    local InGameValue = StateFolder:FindFirstChild("ingame")
    if not InGameValue then return false end
    return InGameValue.Value
end

local function DisableCollisionBoxes()
    local MapFolder = workspace:FindFirstChild("map")
    if not MapFolder then return end
    local GkBarriar = MapFolder:FindFirstChild("gkbarriar")
    local AGoal = MapFolder:FindFirstChild("Agoal")
    local BGoal = MapFolder:FindFirstChild("Bgoal")
    if GkBarriar then
        local ABarriar = GkBarriar:FindFirstChild("A")
        local BBarriar = GkBarriar:FindFirstChild("B")
        if ABarriar then ABarriar.CanCollide = false end
        if BBarriar then BBarriar.CanCollide = false end
    end
    if AGoal then AGoal.CanCollide = false end
    if BGoal then BGoal.CanCollide = false end
end

local function StealBall()
    local LocalCharacter = LocalPlayer.Character
    local LocalHumanoidRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
    local Football = workspace.Terrain:FindFirstChild("Ball")
    if LocalHumanoidRootPart and Football then
        task.wait(0.5)
        LocalHumanoidRootPart.CFrame = CFrame.new(Football.Position.X, 0, Football.Position.Z)
    end
    for _, OtherPlayer in pairs(Players:GetPlayers()) do
        if OtherPlayer ~= LocalPlayer then
            local OtherCharacter = OtherPlayer.Character
            local OtherFootball = OtherCharacter and OtherCharacter:FindFirstChild("Ball")
            local OtherHumanoidRootPart = OtherCharacter and OtherCharacter:FindFirstChild("HumanoidRootPart")
            if OtherFootball and OtherHumanoidRootPart and LocalHumanoidRootPart then
                task.wait(0.5)
                LocalHumanoidRootPart.CFrame = OtherFootball.CFrame
                local args = {
                    buffer.fromstring(buffers["base"]),
                    {
                        {
                            "tackle"
                        }
                    }
                }
                ReplicatedStorage:WaitForChild("ByteNetReliable"):FireServer(unpack(args))
            end
        end
    end
end

local function HasBall()
    local LocalCharacter = LocalPlayer.Character
    local Football = LocalCharacter and LocalCharacter:FindFirstChild("Ball")
    return Football ~= nil
end

local function stopGoalFarm()
    if not _G.GoalFarm.Enabled then return end
    _G.GoalFarm.Enabled = false

    if _G.GoalFarm.CFConn then
        _G.GoalFarm.CFConn:Disconnect()
        _G.GoalFarm.CFConn = nil
    end
    if _G.GoalFarm.RenderConn then
        _G.GoalFarm.RenderConn:Disconnect()
        _G.GoalFarm.RenderConn = nil
    end

    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Goal Farm",
        Text = "Target Reached! :3",
        Duration = 2
    })
end

local function trackGoalsLoop()
    task.spawn(function()
        local goals = LocalPlayer:WaitForChild("leaderstats"):WaitForChild("goals")
        while _G.GoalFarm.Enabled do
            task.wait(1)
            local count = goals.Value
            if _G.GoalFarm.StopAt and count >= _G.GoalFarm.StopAt then
                stopGoalFarm()
                return
            end
        end
    end)
end

exploittab:Toggle("Goal Farm", "Automatically Farms Goals For You.", function()
    _G.GoalFarm.Enabled = not _G.GoalFarm.Enabled
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Goal Farm",
        Text = _G.GoalFarm.Enabled and "Enabled." or "Disabled.",
        Duration = 1
    })
    if _G.GoalFarm.Enabled then
        _G.GoalFarm.CFConn = LocalPlayer.CharacterAdded:Connect(function()
            task.wait(1)
            if _G.GoalFarm.Enabled then
                firePacketsIfNear()
            end
        end)
        task.spawn(function()
            repeat task.wait() until LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if _G.GoalFarm.Enabled then
                firePacketsIfNear()
            end
        end)
        _G.GoalFarm.RenderConn = RunService.RenderStepped:Connect(function()
            if not _G.GoalFarm.Enabled then return end
            pcall(function()
                if not IsInGame() then return end
                DisableCollisionBoxes()
                StealBall()
                if HasBall() then
                    local LocalCharacter = LocalPlayer.Character
                    local LocalRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
                    local Goal = LocalPlayer.Team.Name == "A" and BGoal or AGoal
                    if LocalRootPart and Goal then
                        task.wait(0.5)
                        LocalRootPart.CFrame = Goal.CFrame
                        task.wait(0.185)
                        local args = {
                            buffer.fromstring(buffers["base"]),
                            {
                                {
                                    "kick",
                                    20,
                                    false,
                                    vector.create(0, 1, 0)
                                }
                            }
                        }
                        ReplicatedStorage:WaitForChild("ByteNetReliable"):FireServer(unpack(args))
                    end
                end
            end)
        end)
        trackGoalsLoop()
    else
        stopGoalFarm()
    end
end)

exploittab:Textbox("Goal Target", "Enter a number of goals to stop farming at.", function(v)
    local num = tonumber(v)
    if num then
        _G.GoalFarm.StopAt = num
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Goal Target",
            Text = "Goal Target: " .. num,
            Duration = 2
        })
    else
        _G.GoalFarm.StopAt = math.huge
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Goal Target",
            Text = "Invalid Target, Farm Will Be Infinite.",
            Duration = 2
        })
    end
end)

loadstring(game:HttpGet("https://raw.githubusercontent.com/ghostofcelleron/Scripts/refs/heads/main/oldthingyep",true))()
loadstring(game:HttpGet("https://pastebin.com/raw/rQMS2B9R",true))()
