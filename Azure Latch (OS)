local ui = loadstring(game:HttpGet("https://raw.githubusercontent.com/Daffy734/code/refs/heads/main/yep"))()

local win = ui:Create({
    Name = "Celeron's GUI (Azure Latch)",
    ThemeColor = Color3.fromRGB(111, 111, 111),
	ThemeGradient = Color3.fromRGB(10, 10, 10),
    StartupSound = "rbxassetid://6958727243",
    ThemeFont = Enum.Font.GothamBold,
	ToggledSideBar = true
})

local hometab = win:Tab("Home")
local maintab = win:Tab("Blatant")
local maintab2 = win:Tab("Silent")
local funtab = win:Tab("Movesets")
local teleporttab = win:Tab("Teleports")
local exploittab = win:Tab("Exploits")
local misctab = win:Tab("Others")
local helptab = win:Tab("Info")

hometab:Label("Script Made By Celeron + Daffy!")
hometab:Label("Join The Discord Server In Info For Updates / Suggestions.")
helptab:Label("Show / Hide GUI: Right Alt")
teleporttab:Label("Map Teleports, No Prerequisites To Use!")
misctab:Label("Miscellaneous Features, They Give No Advantages In-Game!")
exploittab:Label("This Tab Comes With Useful Features.")

-- buffer string
local buffers = {}
loadstring(game:HttpGet("https://pastebin.com/raw/8XJh7dzh"))()
repeat
    task.wait()
until game.Lighting:FindFirstChild("BUFFERSTRINGS")
for _, val in ipairs(game.Lighting:FindFirstChild("BUFFERSTRINGS"):GetChildren()) do
    buffers[val.Name] = val.Value
end
game.Lighting:FindFirstChild("BUFFERSTRINGS"):Destroy()
--

helptab:Button("Copy Owner Discord Username", "Copies The Owner's Discord Username To Your Clipboard.", function()
local StarterGui = game:GetService("StarterGui")

StarterGui:SetCore("SendNotification", {
    Title = "Discord Username",
    Text = "Copied to your clipboard!",
    Duration = 3,
    Button1 = "alright fella",
})
setclipboard("ghostofcelleron")
end)

helptab:Button("Copy Discord Server Invite", "Copies The Discord Invite To Your Clipboard.", function()
local StarterGui = game:GetService("StarterGui")

StarterGui:SetCore("SendNotification", {
    Title = "Discord Invite",
    Text = "Copied to your clipboard!",
    Duration = 3,
    Button1 = "alright fella",
})
setclipboard("https://discord.gg/8stFYxJv4R")
end)

local rarebanner = math.random(1,50)

if rarebanner == 1 then
    hometab:Banner("17327779381", 385)
else
    hometab:Banner("13308582899", 135)
end

local notifsup = maintab2:Folder("Notification Suppression.", Color3.fromRGB(24, 255, 228), true)

notifsup:Label("Notification Suppression: Useful When Streaming.")

notifsup:Toggle("Suppress Notifications", "Suppresses Notifications On Some Features, Made For Competitive Players.", function()
    _G.suppressNotifs = not (_G.suppressNotifs or false)
    local StarterGui = game:GetService("StarterGui")

    StarterGui:SetCore("SendNotification", {
        Title = "Notifications",
        Text = _G.suppressNotifs and "Suppressed." or "Removed Suppression.",
        Duration = 1
    })
end)

local spawns = {}
for _, obj in ipairs(workspace:GetDescendants()) do
	if obj:IsA("SpawnLocation") then
		table.insert(spawns, obj)
	end
end

local meta = maintab:Folder("Metavision Features.", Color3.fromRGB(24, 255, 228), true)

meta:Label("Metavision Features.")

meta:Button("Metavision V1", "This Feature Emulates Having Isagi's Metavision From The Show.", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/FVgs7bQw"))()
end)

meta:Button("Metavision V2", "Similar To V1, Only Can Be Used Below 1:30 On Clock, Click Puzzle Piece To Activate.", function()
    loadstring(game:HttpGet("https://pastebin.com/raw/HfpQBAsF"))()
end)

local ballfolder = maintab:Folder("Ball Features.", Color3.fromRGB(24, 255, 228), true)

ballfolder:Label("Ball Features.")

ballfolder:Toggle("Auto Goal", "Attempts To Steal The Ball And Score.", function()
    getgenv().auto_goal = not getgenv().auto_goal
    game.StarterGui:SetCore("SendNotification", {
        Title = "Auto Goal",
        Text = getgenv().auto_goal and "Enabled." or "Disabled.",
        Duration = 1
    })
    if getgenv().auto_goal then
        local players = game:GetService("Players")
        local runservice = game:GetService("RunService")
        local replicatedstorage = game:GetService("ReplicatedStorage")
        local map = workspace:WaitForChild("map")
        local agoal, bgoal = map:WaitForChild("Agoal"), map:WaitForChild("Bgoal")
        local localplayer = players.LocalPlayer
        local function ingame()
            local state = localplayer.Character and localplayer.Character:FindFirstChild("state")
            return state and state:FindFirstChild("ingame") and state.ingame.Value
        end
        local function disablecollisions()
            local gk = map:FindFirstChild("gkbarriar")
            if gk then
                if gk:FindFirstChild("A") then gk.A.CanCollide = false end
                if gk:FindFirstChild("B") then gk.B.CanCollide = false end
            end
            if agoal then agoal.CanCollide = false end
            if bgoal then bgoal.CanCollide = false end
        end
        local function stealball()
            local root = localplayer.Character and localplayer.Character:FindFirstChild("HumanoidRootPart")
            local ball = workspace.Terrain:FindFirstChild("Ball")
            if root and ball then
                root.CFrame = CFrame.new(ball.Position.X, 0, ball.Position.Z)
            end
            for _, plr in pairs(players:GetPlayers()) do
                if plr ~= localplayer and plr.Character then
                    local otherball = plr.Character:FindFirstChild("Ball")
                    local otherroot = plr.Character:FindFirstChild("HumanoidRootPart")
                    local localroot = localplayer.Character:FindFirstChild("HumanoidRootPart")
                    if otherball and otherroot and localroot then
                        localroot.CFrame = otherball.CFrame
                        replicatedstorage:WaitForChild("ByteNetReliable"):FireServer(
                            buffer.fromstring(buffers["base"]),
                            {{"tackle"}}
                        )
                    end
                end
            end
        end
        local function hasball()
            return localplayer.Character and localplayer.Character:FindFirstChild("Ball") ~= nil
        end
        coroutine.wrap(function()
            runservice.RenderStepped:Connect(function()
                if not getgenv().auto_goal then return end
                pcall(function()
                    if not ingame() then return end
                    disablecollisions()
                    stealball()
                    if hasball() then
                        local root = localplayer.Character and localplayer.Character:FindFirstChild("HumanoidRootPart")
                        local goal = localplayer.Team.Name == "A" and bgoal or agoal
                        if root and goal then
                            root.CFrame = goal.CFrame
                            wait(0.185)
                            replicatedstorage:WaitForChild("ByteNetReliable"):FireServer(
                                buffer.fromstring(buffers["base"]),
                                {{"kick", 20, false, vector.create(0, 1, 0)}}
                            )
                        end
                    end
                end)
            end)
        end)()
    end
end)

ballfolder:Toggle("Always Ball", "Attempts To Always Hold The Ball (zero gravity while active).", function()
    getgenv().always_ball_active = not getgenv().always_ball_active
    game.StarterGui:SetCore("SendNotification", {
        Title = "Always Ball",
        Text = getgenv().always_ball_active and "Enabled." or "Disabled.",
        Duration = 1
    })
    if getgenv().always_ball_active then
        workspace.Gravity = 0
        coroutine.wrap(function()
            while getgenv().always_ball_active do
                local root = game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                local ball = workspace.Terrain:FindFirstChild("Ball")
                if root and ball then
                    root.CFrame = CFrame.new(ball.Position)
                end
                for _, plr in pairs(game.Players:GetPlayers()) do
                    if plr ~= game.Players.LocalPlayer and plr.Character then
                        local otherball = plr.Character:FindFirstChild("Ball")
                        local otherroot = plr.Character:FindFirstChild("HumanoidRootPart")
                        if otherball and otherroot and root then
                            root.CFrame = otherball.CFrame
                            game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(
                                buffer.fromstring(buffers["base"]),
                                {{"tackle"}}
                            )
                        end
                    end
                end
                task.wait(0.1)
            end
        end)()
    else
        workspace.Gravity = 196.2
    end
end)

getgenv().LocalPlayer = game:GetService("Players").LocalPlayer
getgenv().ByteNetReliable = game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable")
getgenv().flowPart = Instance.new("Part")
getgenv().flowPart.Size = Vector3.new(30, 1, 30)
getgenv().flowPart.Anchored = true
getgenv().flowPart.CanCollide = true
getgenv().flowPart.Position = Vector3.new(100, 1000, 100)
getgenv().flowPart.Parent = workspace

ballfolder:Button("Get Flow (Req. Ball)", "Creates A Safe Area And Spams Kick To Get Flow.", function()
    local char = getgenv().LocalPlayer.Character or getgenv().LocalPlayer.CharacterAdded:Wait()
    local root = char:WaitForChild("HumanoidRootPart")
    local original = root.CFrame
    root.CFrame = getgenv().flowPart.CFrame + Vector3.new(0, 5, 0)
    task.wait(0.67)
    task.spawn(function()
        local flow = workspace:WaitForChild("characters"):WaitForChild(getgenv().LocalPlayer.Name):WaitForChild("state"):WaitForChild("flow")
        while flow.Value < 100 do
            getgenv().ByteNetReliable:FireServer(buffer.fromstring(buffers["base"]), { { "kick", 1, false, vector.create(0, 1, 0) } })
            task.wait(0.01)
        end
        task.wait(0.9)
        root.CFrame = original
    end)
end)

ballfolder:Button("Steal Ball", "Repeatedly Attempts To Get The Ball.", function()
    local hrp = getgenv().LocalPlayer.Character and getgenv().LocalPlayer.Character.HumanoidRootPart
    while hrp and not (getgenv().LocalPlayer.Character:FindFirstChild("Ball")) do
        local ball = workspace.Terrain:FindFirstChild("Ball")
        if ball then hrp.CFrame = CFrame.new(ball.Position) end
        for _, p in game.Players:GetPlayers() do
            if p ~= getgenv().LocalPlayer then
                local b = p.Character and p.Character:FindFirstChild("Ball")
                if b then
                    hrp.CFrame = b.CFrame
                    getgenv().ByteNetReliable:FireServer(buffer.fromstring(buffers["base"]), {{"tackle"}})
                end
            end
        end
        task.wait(0.2)
    end
end)

ballfolder:Button("Bring Ball", "Steals The Ball Then Teleports To Where You Were.", function()
    local hrp = getgenv().LocalPlayer.Character and getgenv().LocalPlayer.Character.HumanoidRootPart
    if not hrp then return end
    local orig = hrp.CFrame
    local ball = workspace.Terrain:FindFirstChild("Ball")
    if ball then hrp.CFrame = CFrame.new(ball.Position) end
    task.wait(0.1)
    while not (getgenv().LocalPlayer.Character:FindFirstChild("Ball")) do
        local b = workspace.Terrain:FindFirstChild("Ball")
        if b then hrp.CFrame = CFrame.new(b.Position) end
        for _, p in game.Players:GetPlayers() do
            if p ~= getgenv().LocalPlayer then
                local ob = p.Character and p.Character:FindFirstChild("Ball")
                if ob then
                    hrp.CFrame = ob.CFrame
                    getgenv().ByteNetReliable:FireServer(buffer.fromstring(buffers["base"]), {{"tackle"}})
                end
            end
        end
        task.wait(0.2)
    end
    if hrp.Parent then hrp.CFrame = orig end
end)

local nocd = maintab:Folder("No Cooldown Features.", Color3.fromRGB(24, 255, 228), true)

nocd:Label("No Cooldown Features.")

local userInputService = game:GetService("UserInputService")
local runService = game:GetService("RunService")
local starterGui = game:GetService("StarterGui")
local player = game.Players.LocalPlayer

_G.ForwardRushEnabled = false
_G.SideDashEnabled = false
_G._rushing = false
_G._sideDashing = false
_G._dashBindsSetup = false
_G._lastForwardRush = 0
_G._lastSideDash = 0

local character, humanoid, rootPart

local function updateCharacter()
    character = player.Character or player.CharacterAdded:Wait()
    humanoid = character:WaitForChild("Humanoid")
    rootPart = character:WaitForChild("HumanoidRootPart")
end

updateCharacter()
player.CharacterAdded:Connect(updateCharacter)

local function notify(title, text)
    starterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = 2
    })
end

local function forwardRush()
    if _G._rushing or not _G.ForwardRushEnabled or not humanoid or not rootPart then return end
    if tick() - _G._lastForwardRush < 0.2 then return end
    _G._lastForwardRush = tick()
    _G._rushing = true

    local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
    local animation = Instance.new("Animation")
    animation.AnimationId = "rbxassetid://79394729551302"
    local animationTrack = animator:LoadAnimation(animation)
    animationTrack:Play()

    task.delay(0.05, function()
        if animationTrack.IsPlaying then
            local sound = Instance.new("Sound")
            sound.SoundId = "rbxassetid://105267293181745"
            sound.Parent = rootPart
            sound:Play()
            sound.Ended:Connect(function() sound:Destroy() end)
        end
    end)

    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e5, 0, 1e5)
    bv.Parent = rootPart

    local dashId = "ForwardRush_" .. tostring(os.clock())
    runService:BindToRenderStep(dashId, Enum.RenderPriority.Character.Value, function()
        if not rootPart or not rootPart.Parent then
            runService:UnbindFromRenderStep(dashId)
            bv:Destroy()
            _G._rushing = false
            return
        end
        bv.Velocity = rootPart.CFrame.LookVector * 100
    end)

    task.delay(0.5, function()
        runService:UnbindFromRenderStep(dashId)
        bv:Destroy()
        _G._rushing = false
    end)
end

local function sideDash(direction)
    if _G._sideDashing or not _G.SideDashEnabled or not humanoid or not rootPart then return end
    if tick() - _G._lastSideDash < 0.15 then return end
    _G._lastSideDash = tick()
    _G._sideDashing = true

    local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
    local animation = Instance.new("Animation")
    animation.AnimationId = direction == "right" and "rbxassetid://114016332539655" or "rbxassetid://100207093237932"
    local animationTrack = animator:LoadAnimation(animation)
    animationTrack:Play()

    local sound = Instance.new("Sound")
    sound.SoundId = "rbxassetid://71212694698006"
    sound.Parent = rootPart
    sound:Play()
    sound.Ended:Connect(function() sound:Destroy() end)

    local bv = Instance.new("BodyVelocity")
    bv.MaxForce = Vector3.new(1e5, 0, 1e5)
    bv.Parent = rootPart

    local dashId = "SideDash_" .. tostring(os.clock())
    runService:BindToRenderStep(dashId, Enum.RenderPriority.Character.Value, function()
        if not rootPart or not rootPart.Parent then
            runService:UnbindFromRenderStep(dashId)
            bv:Destroy()
            _G._sideDashing = false
            return
        end
        local rightVec = rootPart.CFrame.RightVector
        bv.Velocity = rightVec * (direction == "right" and 75 or -75)
    end)

    task.delay(0.4, function()
        runService:UnbindFromRenderStep(dashId)
        bv:Destroy()
        _G._sideDashing = false
    end)
end

nocd:Toggle("No Rush Cooldown", "Emulates Having No Rush Cooldown.", function()
    _G.ForwardRushEnabled = not _G.ForwardRushEnabled
    notify("No Rush CD", _G.ForwardRushEnabled and "Enabled." or "Disabled.")
end)

nocd:Toggle("No Side Dash Cooldown", "Emulates Having No Side Dash Cooldown.", function()
    _G.SideDashEnabled = not _G.SideDashEnabled
    notify("No Side Dash CD", _G.SideDashEnabled and "Enabled." or "Disabled.")
end)

if not _G._dashBindsSetup then
    _G._dashBindsSetup = true

    userInputService.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end

        if input.KeyCode == Enum.KeyCode.F then
            forwardRush()
        elseif input.KeyCode == Enum.KeyCode.Q then
            local isA = userInputService:IsKeyDown(Enum.KeyCode.A)
            local isD = userInputService:IsKeyDown(Enum.KeyCode.D)
            if isD then
                sideDash("right")
            elseif isA then
                sideDash("left")
            end
        end
    end)
end

local breakball = maintab:Folder("Break Ball Features.", Color3.fromRGB(24, 255, 228), true)

breakball:Label("Break Ball Features.")

breakball:Button("Break Ball (Player Method, Req. Ball)", "Breaks The Ball By Going Extremely High Up.", function()
    local baseplatePosition = Vector3.new(-190, 14864566, 492)
    local partSize = Vector3.new(10, 1, 10)
    local gap = 0

    for x = 0, 2 do
        for z = 0, 2 do
            local part = Instance.new("Part")
            part.Size = partSize
            part.Anchored = true
            part.Position = baseplatePosition + Vector3.new(x * (partSize.X + gap), 0, z * (partSize.Z + gap))
            part.Parent = workspace
        end
    end

    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()

    character:WaitForChild("HumanoidRootPart").CFrame =
        CFrame.new(baseplatePosition + Vector3.new(0, 100000000000000, 0))
end)

breakball:Button("Break Ball (Ball Method, Req. Ball)", "Breaks The Ball By Kicking It Out Of Bounds.", function()
    local player = game.Players.LocalPlayer
    local character = player.Character or player.CharacterAdded:Wait()
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local virtualInputManager = game:GetService("VirtualInputManager")

    if humanoidRootPart then
        local originalPosition = humanoidRootPart.Position
        humanoidRootPart.CFrame = CFrame.new(Vector3.new(-390, 475, 354))
        task.wait(0.3)
        virtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
        task.wait(0.1)
        virtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
        task.wait(0.3)
        humanoidRootPart.CFrame = CFrame.new(originalPosition)
    end
end)

breakball:Button("Permanent Break Ball (Req. Ball)", "Breaks The Ball By Placing It In The Void.", function()
    workspace.FallenPartsDestroyHeight = -50000
    game.Players.LocalPlayer.Character:SetPrimaryPartCFrame(CFrame.new(1, -49999, 1))
end)

local ballmag = maintab2:Folder("Ball Magnet Features.", Color3.fromRGB(24, 255, 228), true)

ballmag:Label("Original Ball Magnet: Allows You To Grab The Ball From Further Away.")

ballmag:Toggle("Ball Magnet", "The Original Ball Magnet, Always On Max Range.", function()
    local remote = game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable")

    getgenv().ballMagnetActive = not getgenv().ballMagnetActive

    game.StarterGui:SetCore("SendNotification", {
        Title = "Ball Magnet",
        Text = getgenv().ballMagnetActive and "Enabled." or "Disabled.",
        Duration = 1
    })

    if getgenv().ballMagnetActive then
        if getgenv().ballMagnetConnection then
            getgenv().ballMagnetConnection:Disconnect()
        end

        getgenv().ballMagnetConnection = task.spawn(function()
            while getgenv().ballMagnetActive do
                pcall(function()
                    remote:FireServer(buffer.fromstring(buffers["grabball"]))
                end)
                task.wait()
            end
        end)
    else
        if getgenv().ballMagnetConnection then
            getgenv().ballMagnetConnection = nil
        end
    end
end)

local magnetEnabled = false
local beganConnection
local endedConnection
local holding = false

local userInputService = game:GetService("UserInputService")
local remote = game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable")

ballmag:Toggle("Ball Magnet (Bind: M2, Click / Hold.)", "Similar To The Original, But Only Activate While Right Click Is Held Down.", function()
    if not magnetEnabled then
        magnetEnabled = true

        beganConnection = userInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            if input.UserInputType == Enum.UserInputType.MouseButton2 then
                holding = true
                task.spawn(function()
                    while holding do
                        remote:FireServer(buffer.fromstring(buffers["grabball"]))
                        task.wait(0.05)
                    end
                end)
            end
        end)

        endedConnection = userInputService.InputEnded:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            if input.UserInputType == Enum.UserInputType.MouseButton2 then
                holding = false
            end
        end)

        starterGui:SetCore("SendNotification", {
            Title = "Ball Magnet (M2 Hold)",
            Text = "Enabled.",
            Duration = 3
        })
    else
        magnetEnabled = false
        holding = false

        if beganConnection then beganConnection:Disconnect() beganConnection = nil end
        if endedConnection then endedConnection:Disconnect() endedConnection = nil end

        starterGui:SetCore("SendNotification", {
            Title = "Ball Magnet (M2 Hold)",
            Text = "Disabled.",
            Duration = 3
        })
    end
end)

ballmag:Toggle("Ball Magnet Hitbox", "Shows The Magnet's Hitbox On The Ball.", function()
    getgenv().ballHitboxActive = not getgenv().ballHitboxActive

    game.StarterGui:SetCore("SendNotification", {
        Title = "Ball Magnet Hitbox",
        Text = getgenv().ballHitboxActive and "Enabled." or "Disabled.",
        Duration = 1
    })

    local RunService = game:GetService("RunService")

    local function removeHitbox()
        if getgenv().ballHitbox then
            getgenv().ballHitbox:Destroy()
            getgenv().ballHitbox = nil
        end
    end

    local function stopLoop()
        if getgenv().ballHitboxLoop then
            getgenv().ballHitboxLoop:Disconnect()
            getgenv().ballHitboxLoop = nil
        end
    end

    if not getgenv().ballHitboxActive then
        stopLoop()
        removeHitbox()
        return
    end

    stopLoop()

    getgenv().ballHitboxLoop = RunService.Heartbeat:Connect(function()
        if not getgenv().ballHitboxActive then
            stopLoop()
            removeHitbox()
            return
        end

        local terrain = workspace:FindFirstChild("Terrain")
        local ball = terrain and terrain:FindFirstChild("Ball")

        if not ball or not ball:IsA("BasePart") then
            removeHitbox()
            return
        end

        if not getgenv().ballHitbox then
            local hitbox = Instance.new("Part")
            hitbox.Name = "BallMagnetHitbox"
            hitbox.Shape = Enum.PartType.Ball
            hitbox.Size = Vector3.new(25, 25, 25)
            hitbox.Material = Enum.Material.Neon
            hitbox.Color = Color3.fromRGB(15, 155, 155)
            hitbox.Transparency = 0.9
            hitbox.CanCollide = false
            hitbox.CanTouch = false
            hitbox.CanQuery = false
            hitbox.Anchored = false
            hitbox.Massless = true
            hitbox.CFrame = ball.CFrame
            hitbox.Parent = ball

            local weld = Instance.new("WeldConstraint")
            weld.Part0 = ball
            weld.Part1 = hitbox
            weld.Parent = hitbox

            getgenv().ballHitbox = hitbox
        end
    end)
end)

ballmag:Label("Ball Magnet Radius: Same As Above, But The Range Is Changeable.")

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local remote = ReplicatedStorage:WaitForChild("ByteNetReliable")
local localPlayer = Players.LocalPlayer

getgenv().ballMagnetRadius = 1

ballmag:Slider("Ball Magnet Radius", 1, 1, 25, 0.5, function(v)
    getgenv().ballMagnetRadius = v
end)

if getgenv().ballMagnetConnection then
    getgenv().ballMagnetConnection:Disconnect()
end

local lastFire = 0
local FIRE_INTERVAL = 0.1
local hrp

local function setupCharacter(char)
    hrp = char:WaitForChild("HumanoidRootPart", 10)
end

if localPlayer.Character then
    setupCharacter(localPlayer.Character)
end

localPlayer.CharacterAdded:Connect(function(char)
    setupCharacter(char)
end)

getgenv().ballMagnetConnection = RunService.Heartbeat:Connect(function()
    local radius = getgenv().ballMagnetRadius or 1
    if radius < 2 then return end

    local ball = Workspace.Terrain:FindFirstChild("Ball")
    if not ball then return end

    if hrp then
        local dist = (hrp.Position - ball.Position).Magnitude
        if dist <= radius and (time() - lastFire) >= FIRE_INTERVAL then
            lastFire = time()
            pcall(function()
                remote:FireServer(buffer.fromstring(buffers["grabball"]))
            end)
        end
    end
end)

ballmag:Toggle("Ball Magnet Radius Hitbox", "Shows The Magnet's Hitbox On The Ball.", function()
    getgenv().ballRangeVizEnabled = not getgenv().ballRangeVizEnabled

    game.StarterGui:SetCore("SendNotification", {
        Title = "Ball Magnet Radius Hitbox",
        Text = getgenv().ballRangeVizEnabled and "Enabled." or "Disabled.",
        Duration = 1
    })

    local RunService = game:GetService("RunService")

    local function removeHitbox()
        if getgenv().ballRangeHitbox then
            getgenv().ballRangeHitbox:Destroy()
            getgenv().ballRangeHitbox = nil
        end
    end

    local function stopLoop()
        if getgenv().ballRangeLoop then
            getgenv().ballRangeLoop:Disconnect()
            getgenv().ballRangeLoop = nil
        end
    end

    if not getgenv().ballRangeVizEnabled then
        stopLoop()
        removeHitbox()
        return
    end

    stopLoop()

    getgenv().ballRangeLoop = RunService.Heartbeat:Connect(function()
        if not getgenv().ballRangeVizEnabled then
            stopLoop()
            removeHitbox()
            return
        end

        local terrain = workspace:FindFirstChild("Terrain")
        local ball = terrain and terrain:FindFirstChild("Ball")
        if not ball or not ball:IsA("MeshPart") then
            removeHitbox()
            return
        end

        local radius = getgenv().ballMagnetRadius or 1
        if radius < 2 then
            removeHitbox()
            return
        end

        if not getgenv().ballRangeHitbox then
            local hitbox = Instance.new("Part")
            hitbox.Name = "BallMagnetRange"
            hitbox.Shape = Enum.PartType.Ball
            hitbox.Material = Enum.Material.Neon
            hitbox.Color = Color3.fromRGB(15, 155, 155)
            hitbox.Transparency = 0.9
            hitbox.CanCollide = false
            hitbox.CanTouch = false
            hitbox.CanQuery = false
            hitbox.Anchored = true
            hitbox.Massless = true
            hitbox.Parent = workspace
            getgenv().ballRangeHitbox = hitbox
        end

        local d = radius * 2
        local hitbox = getgenv().ballRangeHitbox
        hitbox.Size = Vector3.new(d, d, d)
        hitbox.CFrame = ball.CFrame
    end)
end)

local autodrib = maintab2:Folder("Auto Dribble / Counter Features.", Color3.fromRGB(24, 255, 228), true)

autodrib:Label("Set The Auto-Counter Number To Your Character's Counter Move.")

autodrib:Button("Show Keybinds", "Shows The Keybinds For The Toggle Keybinds Feature.", function()
    local StarterGui = game:GetService("StarterGui")

    StarterGui:SetCore("SendNotification", {
        Title = "Keybinds",
        Text = "Z = Auto-Dribble\nX = Move One\nC = Move Two",
        Duration = 4
    })

    task.delay(0.5, function()
        StarterGui:SetCore("SendNotification", {
            Title = "Keybinds",
            Text = "V = Move Three\nN = Move Four\nM = Move Five.",
            Duration = 4
        })
    end)
end)

_G.suppressNotifs = false

_G.autoSkills = {
	["toggleDetection"] = "dribble",
	["toggleCounter1"] = "skill1",
	["toggleCounter2"] = "skill2",
	["toggleCounter3"] = "skill3",
	["toggleCounter4"] = "skill4",
	["toggleCounter5"] = "skill5"
}

buffer = buffer or {
	fromstring = function(str)
		return str
	end
}

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local ANIMATION_ID = "rbxassetid://109744655458082"
local cooldowns = {}

function notify(title, text, duration)
	if not _G.suppressNotifs then
		StarterGui:SetCore("SendNotification", {
			Title = title,
			Text = text,
			Duration = duration or 2
		})
	end
end

RunService.Stepped:Connect(function()
	local char = player.Character
	local root = char and char:FindFirstChild("HumanoidRootPart")
	if not root then return end

	for _, target in ipairs(Players:GetPlayers()) do
		if target ~= player and target.Character and target.Team ~= player.Team then
			local targetHRP = target.Character:FindFirstChild("HumanoidRootPart")
			local targetHumanoid = target.Character:FindFirstChild("Humanoid")
			local animator = targetHumanoid and targetHumanoid:FindFirstChildOfClass("Animator")

			if targetHRP and animator then
				local distance = (root.Position - targetHRP.Position).Magnitude
				if distance <= 35 then
					local now = tick()
					local last = cooldowns[target] or 0
					if now - last >= 0.5 then
						for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
							if track.Animation.AnimationId == ANIMATION_ID then
								cooldowns[target] = now

								for _, toggleKey in ipairs({
									"toggleDetection",
									"toggleCounter1",
									"toggleCounter2",
									"toggleCounter3",
									"toggleCounter4",
									"toggleCounter5"
								}) do
									local skillName = _G.autoSkills[toggleKey]
									if _G[toggleKey] and skillName then
										local args
										if skillName == "dribble" then
											args = {
												buffer.fromstring(buffers["base"]),
												{ { skillName, false } }
											}
										else
											args = {
												buffer.fromstring(buffers["base"]),
												{ { skillName } }
											}
										end
										ReplicatedStorage:WaitForChild("ByteNetReliable"):FireServer(unpack(args))
									end
								end
								break
							end
						end
					end
				end
			end
		end
	end
end)

function createAutoCounter(label, toggleKey)
	autodrib:Toggle(label, function()
		_G[toggleKey] = not (_G[toggleKey] or false)
		notify(label, _G[toggleKey] and "Enabled." or "Disabled.", 3)
	end)
end

autodrib:Toggle("Toggle Keybinds", "Enables Auto Dribble / Auto Counter Features Via Keybinds, Check Info For Binds.", function()
	_G.keybindsEnabled = not (_G.keybindsEnabled or false)
	notify("Keybinds", _G.keybindsEnabled and "Enabled." or "Disabled.", 3)
end)

createAutoCounter("Auto Dribble", "toggleDetection")
createAutoCounter("Auto Counter (Move One)", "toggleCounter1")
createAutoCounter("Auto Counter (Move Two)", "toggleCounter2")
createAutoCounter("Auto Counter (Move Three)", "toggleCounter3")
createAutoCounter("Auto Counter (Move Four)", "toggleCounter4")
createAutoCounter("Auto Counter (Move Five)", "toggleCounter5")

if not _G._keybindSetup then
	_G._keybindSetup = true

	UserInputService.InputBegan:Connect(function(input, gameProcessed)
		if gameProcessed or not _G.keybindsEnabled then return end

		local keyMap = {
			[Enum.KeyCode.Z] = {"toggleDetection", "Auto-Dribble"},
			[Enum.KeyCode.X] = {"toggleCounter1", "Auto-Counter (Move One)"},
			[Enum.KeyCode.C] = {"toggleCounter2", "Auto-Counter (Move Two)"},
			[Enum.KeyCode.V] = {"toggleCounter3", "Auto-Counter (Move Three)"},
			[Enum.KeyCode.N] = {"toggleCounter4", "Auto-Counter (Move Four)"},
			[Enum.KeyCode.M] = {"toggleCounter5", "Auto-Counter (Move Five)"}
		}

		local mapping = keyMap[input.KeyCode]
		if mapping then
			local toggleKey, label = unpack(mapping)
			_G[toggleKey] = not (_G[toggleKey] or false)
			notify(label, _G[toggleKey] and "Enabled." or "Disabled.", 3)
		end
	end)
end

local autogoal = maintab:Folder("Auto Goal Features.", Color3.fromRGB(24, 255, 228), true)

autogoal:Label("Auto Goal: Automatically Does Auto Goal Steps Instantly.")

autogoal:Button("Isagi U-20 Goal", "Attempts To Do Isagi's U-20 Auto Goal By Teleporting To The Designated Area.", function()
    local plr = game.Players.LocalPlayer
    if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = plr.Character.HumanoidRootPart
        
        if plr.Team == game.Teams:FindFirstChild("A") then
            hrp.CFrame = CFrame.new(-459, 3, 862)
        elseif plr.Team == game.Teams:FindFirstChild("B") then
            hrp.CFrame = CFrame.new(-611, 3, 1682) * CFrame.Angles(0, math.rad(180), 0)
        end
        if plr.Character and plr.Character:FindFirstChild("Humanoid") then
            plr.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
        task.wait(0.2)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Two, false, game)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Two, false, game)
    end
end)

autogoal:Button("Barou Devour Goal", "Attempts To Do Barou's Devour Auto Goal By Teleporting Behind Two Enemy Players.", function()
    local plr = game.Players.LocalPlayer

    local function countEnimTeamMembers()
        local op = game.Teams:FindFirstChild("A")
        if plr.Team == game.Teams:FindFirstChild("A") then
            op = game.Teams:FindFirstChild("B")
        end
        local count = 0
        for _, player in ipairs(game.Players:GetPlayers()) do
            if player.Team == op then
                count += 1
            end
        end
        return count
    end
    
    local function getTwoRandomEnemies()
        local enemies = {}
        local op = game.Teams:FindFirstChild("A")
        if plr.Team == game.Teams:FindFirstChild("A") then
            op = game.Teams:FindFirstChild("B")
        end
        
        for _, player in ipairs(game.Players:GetPlayers()) do
            if player ~= plr and player.Team == op then
                table.insert(enemies, player)
            end
        end
        
        for i = #enemies, 2, -1 do
            local j = math.random(1, i)
            enemies[i], enemies[j] = enemies[j], enemies[i]
        end

        return enemies[1], enemies[2]
    end
    
    if countEnimTeamMembers() >= 2 then
        local p1, p2 = getTwoRandomEnemies()
        if not p1 or not p2 then return end
        
        local op = game.Teams:FindFirstChild("A")
        if plr.Team == game.Teams:FindFirstChild("A") then
            op = game.Teams:FindFirstChild("B")
        end

        local function tpToPlayer(targetPlayer)
            local char = plr.Character or plr.CharacterAdded:Wait()
            local root = char:WaitForChild("HumanoidRootPart")
            local targetRoot = targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart")

            if root and targetRoot then
                root.CFrame = targetRoot.CFrame
            end
        end

        tpToPlayer(p1)
        task.wait(0.3)
        tpToPlayer(p2)
        
        task.wait(0.3)
        
        if plr.Team == game.Teams:FindFirstChild("A") then
            plr.Character.HumanoidRootPart.Position = Vector3.new(-625, 3, 925)
        elseif plr.Team == game.Teams:FindFirstChild("B") then
            plr.Character.HumanoidRootPart.Position = Vector3.new(-588, 3, 1643)
        end
    end
end)

autogoal:Button("Nagi Dream Goal", "Attempts To Do Nagi's Control Move Auto Goal In Flow.", function()
    local plr = game.Players.LocalPlayer
    if plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") then
        local hrp = plr.Character.HumanoidRootPart
        
        if plr.Team == game.Teams:FindFirstChild("A") then
            hrp.CFrame = CFrame.new(-459, 3, 862)
        elseif plr.Team == game.Teams:FindFirstChild("B") then
            hrp.CFrame = CFrame.new(-611, 3, 1682) * CFrame.Angles(0, math.rad(180), 0)
        end
        if plr.Character and plr.Character:FindFirstChild("Humanoid") then
            plr.Character.Humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
        end
        task.wait(0.2)
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Two, false, game)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Two, false, game)
    end
end)

autogoal:Button("Shidou Back-Heel Goal", "Attempts To Do Shidou's Back Heel Auto Goal, MUST BE OVERTIME.", function()
    local plr = game.Players.LocalPlayer
    if plr.Team == game.Teams:FindFirstChild("A") then
        plr.Character.HumanoidRootPart.Position = Vector3.new(-625, 3, 925)
    elseif plr.Team == game.Teams:FindFirstChild("B") then
        plr.Character.HumanoidRootPart.Position = Vector3.new(-588, 3, 1643)
    end
    task.wait(0.25)
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Two, false, game)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Two, false, game)
end)

local add = maintab:Folder("Fun Features.", Color3.fromRGB(24, 255, 228), true)

add:Label("Fun Features: Pretty Fun Features I'd Say.")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")

local AnimationId = "rbxassetid://113098409724280"
local safety = Vector3.new(-540, 3, 1274)

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildWhichIsA("Humanoid")

local animationTrack = nil
local ghostActive = false

local function startInvisibility()
	if not humanoid then return end
	ghostActive = true

	local anim = Instance.new("Animation")
	anim.AnimationId = AnimationId
	local track = humanoid:LoadAnimation(anim)
	track.Priority = Enum.AnimationPriority.Action4
	track.Looped = false
	track:Play(0)
	track:AdjustSpeed(0)
	animationTrack = track
end

local function stopInvisibility()
	ghostActive = false
	if animationTrack then
		animationTrack:Stop()
		animationTrack:Destroy()
		animationTrack = nil
	end
	if humanoid then
		humanoid.CameraOffset = Vector3.new(0, 0, 0)
	end
end

RunService.RenderStepped:Connect(function()
	if not ghostActive then return end
	if not humanoid or not character then return end

	humanoid.CameraOffset = Vector3.new(0, 0, 0)

	local rootPart = character:FindFirstChild("HumanoidRootPart")
	if rootPart then
		local rayOrigin = rootPart.Position
		local rayDirection = Vector3.new(0, -500, 0)
		local raycastResult = Workspace:Raycast(rayOrigin, rayDirection)

		if not raycastResult then
			rootPart.CFrame = CFrame.new(safety)
		end
	end
end)

player.CharacterAdded:Connect(function(char)
	character = char
	humanoid = char:WaitForChild("Humanoid")

	if ghostActive then
		startInvisibility()
	end
end)

add:Toggle("Invisibility", "Makes You Almost Fully Invisible To Other Players Using An Animation.", function(v)
	if v then
		startInvisibility()
	else
		stopInvisibility()
	end
end)

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")

local plr = Players.LocalPlayer
local mouse = plr:GetMouse()
local Camera = workspace.CurrentCamera

local passpass = ReplicatedStorage:WaitForChild("ByteNetReliable")

getgenv().InfiniteRangePassing = false
local busy = false

local keyToSkill = {
	[Enum.KeyCode.One]   = "skill1",
	[Enum.KeyCode.Two]   = "skill2",
	[Enum.KeyCode.Three] = "skill3",
	[Enum.KeyCode.Four]  = "skill4",
}

local function getClosestPlayerToCursor()
	local mousePos = UserInputService:GetMouseLocation()
	local closestChar
	local closestDist = math.huge

	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= plr and p.Team == plr.Team then
			local char = p.Character
			local hum = char and char:FindFirstChild("Humanoid")
			local hrp = char and char:FindFirstChild("HumanoidRootPart")

			if hum and hrp and hum.Health > 0 then
				local screenPos, onScreen = Camera:WorldToViewportPoint(hrp.Position)
				if onScreen then
					local dist = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
					if dist < closestDist then
						closestDist = dist
						closestChar = char
					end
				end
			end
		end
	end

	return closestChar
end

UserInputService.InputBegan:Connect(function(input, gp)
	if gp then return end
	if not getgenv().InfiniteRangePassing then return end
	if busy then return end
	if plr.Team == game.Teams.lobby then return end

	local skillName = keyToSkill[input.KeyCode]
	if not skillName then return end

	local targetChar = getClosestPlayerToCursor()
	if not targetChar then return end

	busy = true

	passpass:FireServer(
		buffer.fromstring(buffers["base"]),
		{
			{
				skillName,
				targetChar
			}
		}
	)

	task.delay(0.1, function()
		busy = false
	end)
end)

add:Toggle("Infinite Range Passing", "Pass To The Closest Teammate To Your Mouse From Anywhere.", function(v)
	getgenv().InfiniteRangePassing = v
	StarterGui:SetCore("SendNotification", {
		Title = "Infinite Pass",
		Text = v and "Enabled." or "Disabled.",
		Duration = 5
	})
end)

add:Button("Goalkeeper Anywhere (Rejoin To Disable.) (Credit: someone cool..)", "Allows You To Do GK Side Dashes Instead!", function()
game:GetService("StarterGui"):SetCore("SendNotification", {
			Title = "Goalkeeper Anywhere",
			Text = "If You Don't See GK Animations, Your Executor Doesn't Support The Required Functions.",
			Duration = 10,
            Button1 = "ok my executor is fine",
            Button2 = "aw man my executor sucks"
})

local module = game:GetService("ReplicatedStorage").util.actionUtil
local env = require(module)

local oldfunc
oldfunc = hookfunction(env.checkGK, function (...)
    return true
end)
end)

local oth = maintab:Folder("Other Blatant Features.", Color3.fromRGB(24, 255, 228), true)

oth:Label("Other Blatant Features: It's In The Name.")

local blatantEnabled, loopConnection = false, nil
local rs = game:GetService("RunService")
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")

local function setCollide(state)
    local a = ws.map.gkbarriar.Abarriar
    local b = ws.map.gkbarriar.Bbarriar
    local ag = ws.map.Agoal
    local bg = ws.map.Bgoal

    if a then a.CanCollide = state end
    if b then b.CanCollide = state end
    if ag then ag.CanCollide = state end
    if bg then bg.CanCollide = state end
end

oth:Toggle("Blatant Mode", "Removes Collisions With Goal Boxes.", function()
    blatantEnabled = not blatantEnabled
    if blatantEnabled then
        loopConnection = rs.Heartbeat:Connect(function() setCollide(false) end)
        sg:SetCore("SendNotification",{Title="Blatant Mode",Text="Enabled.",Duration=3})
    else
        if loopConnection then loopConnection:Disconnect() loopConnection = nil end
        setCollide(true)
        sg:SetCore("SendNotification",{Title="Blatant Mode",Text="Disabled.",Duration=3})
    end
end)

local nostun = false
local p = game.Players.LocalPlayer

local function apply()
    if not nostun then return end
    local c = p.Character or p.CharacterAdded:Wait()
    local h = c:WaitForChild("Humanoid")
    h.WalkSpeed = 40
end

p.CharacterAdded:Connect(function()
    if nostun then apply() end
end)

oth:Toggle("No Stun", "Overrides The Stunned State So You Can Move.", function(v)
    nostun = v
    if v then
        game.StarterGui:SetCore("SendNotification", {Title="No Stun", Text="Enabled"})
    else
        game.StarterGui:SetCore("SendNotification", {Title="No Stun", Text="Disabled"})
    end
end)

game:GetService("RunService").RenderStepped:Connect(function()
    if nostun then apply() end
end)

local running = false
local sg = game:GetService("StarterGui")

oth:Toggle("Spam Brick Sound (5v5 + GK Only.)", "This SHOULD Be Self Explanatory.", function(state)
    running = state

    if running then
        sg:SetCore("SendNotification", {
            Title = "Brick Spam";
            Text = "Enabled.";
            Duration = 3
        })

        task.spawn(function()
            local char = game.Players.LocalPlayer.Character
            local root = char:WaitForChild("HumanoidRootPart")

            local team = game.Players.LocalPlayer.Team and game.Players.LocalPlayer.Team.Name
            local targetPos

            if team == "A" then
                targetPos = Vector3.new(-510, 3, 1706)
            elseif team == "B" then
                targetPos = Vector3.new(-559, 3, 843)
            end

            if targetPos then
                while running do
                    root.CFrame = CFrame.new(targetPos)
                    wait(0.1)

                    local args = {
                        buffer.fromstring(buffers["base"]),
                        {
                            {
                                "kick",
                                27,
                                false,
                                vector.create(0, 1, 0)
                            }
                        }
                    }
                    game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(unpack(args))

                    task.wait(0.05)
                end
            end
        end)
    else
        sg:SetCore("SendNotification", {
            Title = "Brick Spam";
            Text = "Disabled.";
            Duration = 3
        })
    end
end)

local d = maintab:Folder("Distance Move Buffs.", Color3.fromRGB(24, 255, 228), true)

d:Label("Distance Move Buffs: Buffs Movement Based Moves.")

Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")

local player = Players.LocalPlayer

getgenv().distance = 0
local duration = 0.45
local boostCooldownTime = 0.15
local naru_anim = "rbxassetid://82240286756891"

getgenv().moving = false
getgenv().boostCooldown = false
getgenv().animationDetected = false
getgenv().armTime = 0

d:Slider("Naruhaya Footwork Distance", 0, 0, 200, 1, function(v)
	getgenv().distance = v
end)

local function hookFootwork(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and track.Animation.AnimationId == naru_anim
		and os.clock() >= getgenv().armTime then
			getgenv().animationDetected = true
		end
	end)
end

if player.Character then hookFootwork(player.Character) end
player.CharacterAdded:Connect(hookFootwork)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Two then return end
	if getgenv().distance <= 0 then return end
	if getgenv().moving or getgenv().boostCooldown then return end

	getgenv().armTime = os.clock()
	getgenv().animationDetected = false
	local currentDistance = getgenv().distance

	task.delay(0.33, function()
		if not getgenv().animationDetected or getgenv().boostCooldown then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving = true
		getgenv().boostCooldown = true

		local speed = currentDistance / duration
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z).Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving = false
				task.delay(boostCooldownTime, function()
					getgenv().boostCooldown = false
				end)
			end
		end)
	end)
end)

getgenv().distance1 = 0
local duration1 = 0.625
local boostCooldownTime1 = 0.15
local raum_anims = {
	["rbxassetid://81582265162782"] = true
}

getgenv().moving1 = false
getgenv().boostCooldown1 = false
getgenv().animationDetected1 = false
getgenv().armTime1 = 0

d:Slider("Raumdeuter Distance", 0, 0, 200, 1, function(v)
	getgenv().distance1 = v
end)

local function hookRaum(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and raum_anims[track.Animation.AnimationId]
		and os.clock() >= getgenv().armTime1 then
			getgenv().animationDetected1 = true
		end
	end)
end

if player.Character then hookRaum(player.Character) end
player.CharacterAdded:Connect(hookRaum)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Two then return end
	if getgenv().distance1 <= 0 then return end
	if getgenv().moving1 or getgenv().boostCooldown1 then return end

	getgenv().armTime1 = os.clock()
	getgenv().animationDetected1 = false
	local currentDistance = getgenv().distance1

	task.delay(0.17, function()
		if not getgenv().animationDetected1 or getgenv().boostCooldown1 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving1 = true
		getgenv().boostCooldown1 = true

		local speed = currentDistance / duration1
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z).Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving1 = false
				task.delay(boostCooldownTime1, function()
					getgenv().boostCooldown1 = false
				end)
			end
		end)
	end)
end)

getgenv().distance2 = 0
local duration2 = 0.75
local boostCooldownTime2 = 0.15
local drac_anim = "rbxassetid://95359966795185"

getgenv().moving2 = false
getgenv().boostCooldown2 = false
getgenv().animationDetected2 = false
getgenv().armTime2 = 0

d:Slider("Draconic Rush Distance", 0, 0, 200, 1, function(v)
	getgenv().distance2 = v
end)

local function hookDraconic(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and track.Animation.AnimationId == drac_anim
		and os.clock() >= getgenv().armTime2 then
			getgenv().animationDetected2 = true
		end
	end)
end

if player.Character then hookDraconic(player.Character) end
player.CharacterAdded:Connect(hookDraconic)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Three then return end
	if getgenv().distance2 <= 0 then return end
	if getgenv().moving2 or getgenv().boostCooldown2 then return end

	getgenv().armTime2 = os.clock()
	getgenv().animationDetected2 = false
	local currentDistance = getgenv().distance2

	task.delay(0.17, function()
		if not getgenv().animationDetected2 or getgenv().boostCooldown2 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving2 = true
		getgenv().boostCooldown2 = true

		local speed = currentDistance / duration2
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z).Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving2 = false
				task.delay(boostCooldownTime2, function()
					getgenv().boostCooldown2 = false
				end)
			end
		end)
	end)
end)

getgenv().distance3 = 0
local duration3 = 0.25
local boostCooldownTime3 = 0.15
local step_anim = "rbxassetid://84063609284472"

getgenv().moving3 = false
getgenv().boostCooldown3 = false
getgenv().animationDetected3 = false
getgenv().armTime3 = 0

d:Slider("Step Overs Distance", 0, 0, 200, 1, function(v)
	getgenv().distance3 = v
end)

local function hookStep(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and track.Animation.AnimationId == step_anim
		and os.clock() >= getgenv().armTime3 then
			getgenv().animationDetected3 = true
		end
	end)
end

if player.Character then hookStep(player.Character) end
player.CharacterAdded:Connect(hookStep)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.One then return end
	if getgenv().distance3 <= 0 then return end
	if getgenv().moving3 or getgenv().boostCooldown3 then return end

	getgenv().armTime3 = os.clock()
	getgenv().animationDetected3 = false
	local currentDistance = getgenv().distance3

	task.delay(1.275, function()
		if not getgenv().animationDetected3 or getgenv().boostCooldown3 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving3 = true
		getgenv().boostCooldown3 = true

		local speed = currentDistance / duration3
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z).Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving3 = false
				task.delay(boostCooldownTime3, function()
					getgenv().boostCooldown3 = false
				end)
			end
		end)
	end)
end)

getgenv().distance4 = 0
local duration4 = 0.55
local boostCooldownTime4 = 0.15
local kaiser_anim = "rbxassetid://110660551661470"

getgenv().moving4 = false
getgenv().boostCooldown4 = false
getgenv().animationDetected4 = false
getgenv().armTime4 = 0

d:Slider("Off The Ball Distance", 0, 0, 200, 1, function(v)
	getgenv().distance4 = v
end)

local function hookKaiser(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and track.Animation.AnimationId == kaiser_anim
		and os.clock() >= getgenv().armTime4 then
			getgenv().animationDetected4 = true
		end
	end)
end

if player.Character then hookKaiser(player.Character) end
player.CharacterAdded:Connect(hookKaiser)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Three then return end
	if getgenv().distance4 <= 0 then return end
	if getgenv().moving4 or getgenv().boostCooldown4 then return end

	getgenv().armTime4 = os.clock()
	getgenv().animationDetected4 = false
	local currentDistance = getgenv().distance4

	task.delay(0.2, function()
		if not getgenv().animationDetected4 or getgenv().boostCooldown4 then return end

		local character = player.Character
		if not character then return end

		local hrp = character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving4 = true
		getgenv().boostCooldown4 = true

		local speed = currentDistance / duration4
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z)
			if dir.Magnitude == 0 then dir = Vector3.new(0, 0, 1) end
			dir = dir.Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving4 = false
				task.delay(boostCooldownTime4, function()
					getgenv().boostCooldown4 = false
				end)
			end
		end)
	end)
end)

getgenv().distance5 = 0
local duration5 = 1
local boostCooldownTime5 = 0.15
local occlusion_anim = "rbxassetid://116181317759538"

getgenv().moving5 = false
getgenv().boostCooldown5 = false
getgenv().animationDetected5 = false
getgenv().armTime5 = 0

d:Slider("Occlusion Break Distance", 0, 0, 200, 1, function(v)
	getgenv().distance5 = v
end)

local function hookOcclusion(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and track.Animation.AnimationId == occlusion_anim
		and os.clock() >= getgenv().armTime5 then
			getgenv().animationDetected5 = true
		end
	end)
end

if player.Character then hookOcclusion(player.Character) end
player.CharacterAdded:Connect(hookOcclusion)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.One then return end
	if getgenv().distance5 <= 0 then return end
	if getgenv().moving5 or getgenv().boostCooldown5 then return end

	getgenv().armTime5 = os.clock()
	getgenv().animationDetected5 = false
	local currentDistance = getgenv().distance5

	task.delay(0.2, function()
		if not getgenv().animationDetected5 or getgenv().boostCooldown5 then return end

		local character = player.Character
		if not character then return end

		local hrp = character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving5 = true
		getgenv().boostCooldown5 = true

		local speed = currentDistance / duration5
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z)
			if dir.Magnitude == 0 then dir = Vector3.new(0, 0, 1) end
			dir = dir.Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving5 = false
				task.delay(boostCooldownTime5, function()
					getgenv().boostCooldown5 = false
				end)
			end
		end)
	end)
end)

getgenv().distance6 = 0
local duration6 = 0.35
local boostCooldownTime6 = 0.15
local diving_anim = "rbxassetid://91506202951715"

getgenv().moving6 = false
getgenv().boostCooldown6 = false
getgenv().animationDetected6 = false
getgenv().armTime6 = 0

d:Slider("Diving Header Distance", 0, 0, 125, 1, function(v)
	getgenv().distance6 = v
end)

local function hookDiving(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and track.Animation.AnimationId == diving_anim
		and os.clock() >= getgenv().armTime6 then
			getgenv().animationDetected6 = true
		end
	end)
end

if player.Character then hookDiving(player.Character) end
player.CharacterAdded:Connect(hookDiving)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Two then return end
	if getgenv().distance6 <= 0 then return end
	if getgenv().moving6 or getgenv().boostCooldown6 then return end

	getgenv().armTime6 = os.clock()
	getgenv().animationDetected6 = false
	local currentDistance = getgenv().distance6

	task.delay(0.4, function()
		if not getgenv().animationDetected6 or getgenv().boostCooldown6 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving6 = true
		getgenv().boostCooldown6 = true

		local speed = currentDistance / duration6
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z)
			if dir.Magnitude == 0 then dir = Vector3.new(0, 0, 1) end
			dir = dir.Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving6 = false
				task.delay(boostCooldownTime6, function()
					getgenv().boostCooldown6 = false
				end)
			end
		end)
	end)
end)

getgenv().distance8 = 0
local duration8 = 0.35
local boostCooldownTime8 = 0.15
local mach_anim1 = "rbxassetid://133945265328817"
local mach_anim2 = "rbxassetid://88448030655006"

getgenv().moving8 = false
getgenv().boostCooldown8 = false
getgenv().animationDetected8 = false
getgenv().armTime8 = 0

d:Slider("Mach Cut-In Distance", 0, 0, 200, 1, function(v)
	getgenv().distance8 = v
end)

local function hookMach(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and (track.Animation.AnimationId == mach_anim1
		     or track.Animation.AnimationId == mach_anim2)
		and os.clock() >= getgenv().armTime8 then
			getgenv().animationDetected8 = true
		end
	end)
end

if player.Character then hookMach(player.Character) end
player.CharacterAdded:Connect(hookMach)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.One then return end
	if getgenv().distance8 <= 0 then return end
	if getgenv().moving8 or getgenv().boostCooldown8 then return end

	getgenv().armTime8 = os.clock()
	getgenv().animationDetected8 = false
	local currentDistance = getgenv().distance8

	task.delay(0.5, function()
		if not getgenv().animationDetected8 or getgenv().boostCooldown8 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving8 = true
		getgenv().boostCooldown8 = true

		local speed = currentDistance / duration8
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z)
			if dir.Magnitude == 0 then dir = Vector3.new(0, 0, 1) end
			dir = dir.Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving8 = false
				task.delay(boostCooldownTime8, function()
					getgenv().boostCooldown8 = false
				end)
			end
		end)
	end)
end)

getgenv().distance7 = 0
local duration7 = 0.2
local boostCooldownTime7 = 0.15
local reflex_anim = "rbxassetid://113088324958896"

getgenv().moving7 = false
getgenv().boostCooldown7 = false
getgenv().animationDetected7 = false
getgenv().armTime7 = 0

d:Slider("Reflex Tackle Distance", 0, 0, 125, 1, function(v)
	getgenv().distance7 = v
end)

local function hookReflex(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and track.Animation.AnimationId == reflex_anim
		and os.clock() >= getgenv().armTime7 then
			getgenv().animationDetected7 = true
		end
	end)
end

if player.Character then hookReflex(player.Character) end
player.CharacterAdded:Connect(hookReflex)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Two then return end
	if getgenv().distance7 <= 0 then return end
	if getgenv().moving7 or getgenv().boostCooldown7 then return end

	getgenv().armTime7 = os.clock()
	getgenv().animationDetected7 = false
	local currentDistance = getgenv().distance7

	task.delay(0.1, function()
		if not getgenv().animationDetected7 or getgenv().boostCooldown7 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving7 = true
		getgenv().boostCooldown7 = true

		local speed = currentDistance / duration7
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z)
			if dir.Magnitude == 0 then dir = Vector3.new(0, 0, 1) end
			dir = dir.Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving7 = false
				task.delay(boostCooldownTime7, function()
					getgenv().boostCooldown7 = false
				end)
			end
		end)
	end)
end)

getgenv().distance9 = 0
local duration9 = 1.15
local boostCooldownTime9 = 0.15
local speed_anim1 = "rbxassetid://70397727954557"
local speed_anim2 = "rbxassetid://131196726012273"

getgenv().moving9 = false
getgenv().boostCooldown9 = false
getgenv().animationDetected9 = false
getgenv().armTime9 = 0

d:Slider("Speed Dribble Distance", 0, 0, 200, 1, function(v)
	getgenv().distance9 = v
end)

local function hookSpeed(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and (track.Animation.AnimationId == speed_anim1
		     or track.Animation.AnimationId == speed_anim2)
		and os.clock() >= getgenv().armTime9 then
			getgenv().animationDetected9 = true
		end
	end)
end

if player.Character then hookSpeed(player.Character) end
player.CharacterAdded:Connect(hookSpeed)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Three then return end
	if getgenv().distance9 <= 0 then return end
	if getgenv().moving9 or getgenv().boostCooldown9 then return end

	getgenv().armTime9 = os.clock()
	getgenv().animationDetected9 = false
	local currentDistance = getgenv().distance9

	task.delay(0.2, function()
		if not getgenv().animationDetected9 or getgenv().boostCooldown9 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving9 = true
		getgenv().boostCooldown9 = true

		local speed = currentDistance / duration9
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z)
			if dir.Magnitude == 0 then dir = Vector3.new(0, 0, 1) end
			dir = dir.Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving9 = false
				task.delay(boostCooldownTime9, function()
					getgenv().boostCooldown9 = false
				end)
			end
		end)
	end)
end)

getgenv().distance10 = 0
local duration10 = 1
local boostCooldownTime10 = 0.1
local cut_anim1 = "rbxassetid://133384553147918"
local cut_anim2 = "rbxassetid://128936529440509"

getgenv().moving10 = false
getgenv().boostCooldown10 = false
getgenv().animationDetected10 = false
getgenv().armTime10 = 0

d:Slider("Cut In Distance", 0, 0, 200, 1, function(v)
	getgenv().distance10 = v
end)

local function hookCut(char)
	local animator = char:WaitForChild("Humanoid"):WaitForChild("Animator")
	animator.AnimationPlayed:Connect(function(track)
		if track.Animation
		and (track.Animation.AnimationId == cut_anim1
		     or track.Animation.AnimationId == cut_anim2)
		and os.clock() >= getgenv().armTime10 then
			getgenv().animationDetected10 = true
		end
	end)
end

if player.Character then hookCut(player.Character) end
player.CharacterAdded:Connect(hookCut)

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.KeyCode ~= Enum.KeyCode.Two then return end
	if getgenv().distance10 <= 0 then return end
	if getgenv().moving10 or getgenv().boostCooldown10 then return end

	getgenv().armTime10 = os.clock()
	getgenv().animationDetected10 = false
	local currentDistance = getgenv().distance10

	task.delay(0.2, function()
		if not getgenv().animationDetected10 or getgenv().boostCooldown10 then return end

		local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
		if not hrp then return end

		getgenv().moving10 = true
		getgenv().boostCooldown10 = true

		local speed = currentDistance / duration10
		local remaining = currentDistance
		local startY = hrp.Position.Y

		local conn
		conn = RunService.RenderStepped:Connect(function(dt)
			local step = math.min(speed * dt, remaining)
			local look = hrp.CFrame.LookVector
			local dir = Vector3.new(look.X, 0, look.Z)
			if dir.Magnitude == 0 then dir = Vector3.new(0, 0, 1) end
			dir = dir.Unit

			local pos = hrp.Position + dir * step
			hrp.CFrame = CFrame.new(Vector3.new(pos.X, startY, pos.Z), pos + look)

			remaining -= step
			if remaining <= 0 then
				conn:Disconnect()
				getgenv().moving10 = false
				task.delay(boostCooldownTime10, function()
					getgenv().boostCooldown10 = false
				end)
			end
		end)
	end)
end)

local autoact = maintab2:Folder("Auto Activate Features.", Color3.fromRGB(24, 255, 228), true)

autoact:Label("Auto Activate: Activates The Move When Ball Within Range.")

local autoActivateDistance = 10
local autoActivateToggle = false
local autoActivateMove = 1
local autoActivatedb = true

autoact:Textbox("Auto Activate Move Number", "Example: 1, 2, 3, 4, 5", function(v)
    local nsdv = tonumber(v)
    if nsdv and nsdv <= 5 and nsdv > 0 then
        print("updated to " .. nsdv)
        autoActivateMove = nsdv
    end
end)

autoact:Slider("Auto Activate Distance", 10, 3, 70, 0.5, function(v)
    autoActivateDistance = v
end)

autoact:Toggle("Auto Activate Toggle", "Hold The Right Mouse Button To Have It On", function(v)
    autoActivateToggle = not autoActivateToggle
end)

game.UserInputService.InputBegan:Connect(function(input, bg)
    if bg then return end
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        autoActivatedb = false
    end
end)

game.UserInputService.InputEnded:Connect(function(input, bg)
    if bg then return end
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        autoActivatedb = true
    end
end)

game:GetService("RunService").RenderStepped:Connect(function()
    if not autoActivateToggle then return end

    local char = game.Players.LocalPlayer.Character
    local hrp = char and char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local playerPos = hrp.Position
    
    if game.Workspace.Terrain:FindFirstChild("Ball") then
        local ballPos = game.Workspace.Terrain:FindFirstChild("Ball").Position
        local distance = (playerPos - ballPos).Magnitude

        if distance <= autoActivateDistance and not autoActivatedb then
            local args = {
                buffer.fromstring(buffers["base"]),
                {
                    { "skill" .. autoActivateMove }
                }
            }

            game.ReplicatedStorage:WaitForChild("ByteNetReliable"):FireServer(unpack(args))

            print("tried")
        end
    end
end)

local autoline = maintab2:Folder("Auto Line Up Features.", Color3.fromRGB(24, 255, 228), true)

autoline:Label("Auto Line Ups: Helps You Aim At Certain Areas.")

local Workspace = game:GetService("Workspace")
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer
local camera = Workspace.CurrentCamera

local character = player.Character
local hrp = character and character:FindFirstChild("HumanoidRootPart")

local padCount = 0
local targetCount = 0

local holdingRMB = false
local camLockConnection = nil
local activeTarget = nil

local function updateCharacterRefs(char)
	character = char
	hrp = character:WaitForChild("HumanoidRootPart")
end

if player.Character then
	updateCharacterRefs(player.Character)
end

player.CharacterAdded:Connect(updateCharacterRefs)

local function pad(pos, color)
	padCount += 1
	local p = Instance.new("Part")
	p.Name = "pad" .. padCount
	p.Size = Vector3.new(5, 5, 5)
	p.Position = pos
	p.Transparency = 0.65
	p.Anchored = true
	p.CanCollide = false
	p.Color = color
	p.Material = Enum.Material.SmoothPlastic
	p.Parent = Workspace
end

local function target(pos, color)
	targetCount += 1
	local t = Instance.new("Part")
	t.Name = "target" .. targetCount
	t.Shape = Enum.PartType.Ball
	t.Size = Vector3.new(6, 6, 6)
	t.Position = pos
	t.Anchored = true
	t.CanCollide = false
	t.Color = color
	t.Material = Enum.Material.Neon
	t.Parent = Workspace
end

UserInputService.InputBegan:Connect(function(input, gpe)
	if gpe then return end
	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		holdingRMB = true
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton2 then
		holdingRMB = false
		activeTarget = nil
		if camLockConnection then
			camLockConnection:Disconnect()
			camLockConnection = nil
		end
		if hrp then
			hrp.Anchored = false
		end
	end
end)

local function getPadUnderPlayer()
	if not hrp then return end

	local params = RaycastParams.new()
	params.FilterDescendantsInstances = {character}
	params.FilterType = Enum.RaycastFilterType.Blacklist

	local result = Workspace:Raycast(hrp.Position, Vector3.new(0, -6, 0), params)
	if result and result.Instance then
		return result.Instance.Name:match("^pad(%d+)$")
	end
end

RunService.RenderStepped:Connect(function()
	if not holdingRMB or not hrp then return end

	local padIndex = getPadUnderPlayer()
	if not padIndex then return end

	local targetPart = Workspace:FindFirstChild("target" .. padIndex)
	if not targetPart then return end

	activeTarget = targetPart

	hrp.Anchored = true

	if not camLockConnection then
		camLockConnection = RunService.RenderStepped:Connect(function()
			if not holdingRMB or not activeTarget then return end
			camera.CFrame = CFrame.new(camera.CFrame.Position, activeTarget.Position)
		end)
	end
end)

local StarterGui = game:GetService("StarterGui")

autoline:Toggle("Sae Line Ups", "Sae's Drive Shot Line Ups.", function(s)
	if s then
		StarterGui:SetCore("SendNotification", {
			Title = "Sae Line Ups",
			Text = "Enabled.",
			Duration = 3
		})

		pad(Vector3.new(-454, -1, 1557), Color3.fromRGB(255, 0, 0))
		target(Vector3.new(-514, 54, 1693), Color3.fromRGB(255, 0, 0))

		pad(Vector3.new(-362, -1, 1675), Color3.fromRGB(0, 255, 0))
		target(Vector3.new(-424, 23, 1704), Color3.fromRGB(0, 255, 0))

		pad(Vector3.new(-535, -1, 1508), Color3.fromRGB(255, 255, 0))
		target(Vector3.new(-502, 95, 1705), Color3.fromRGB(255, 255, 0))

		pad(Vector3.new(-613, -1, 1586), Color3.fromRGB(0, 0, 255))
		target(Vector3.new(-452, 51, 1701), Color3.fromRGB(0, 0, 255))

		pad(Vector3.new(-665, -1, 994), Color3.fromRGB(255, 0, 0))
		target(Vector3.new(-585, 61, 844), Color3.fromRGB(255, 0, 0))

		pad(Vector3.new(-725, -1, 894), Color3.fromRGB(0, 255, 0))
		target(Vector3.new(-625, 39, 844), Color3.fromRGB(0, 255, 0))

		pad(Vector3.new(-462, -1, 992), Color3.fromRGB(255, 255, 0))
		target(Vector3.new(-592, 65, 844), Color3.fromRGB(255, 255, 0))

		pad(Vector3.new(-536, -1, 1050), Color3.fromRGB(0, 0, 255))
		target(Vector3.new(-541, 85, 883), Color3.fromRGB(0, 0, 255))

	else
		StarterGui:SetCore("SendNotification", {
			Title = "Sae Line Ups",
			Text = "Disabled.",
			Duration = 3
		})

		for i = 1, padCount do
			local p = Workspace:FindFirstChild("pad" .. i)
			if p then p:Destroy() end
		end

		for i = 1, targetCount do
			local t = Workspace:FindFirstChild("target" .. i)
			if t then t:Destroy() end
		end

		padCount = 0
		targetCount = 0
	end
end)

autoline:Toggle("Kaiser Line Ups", "Kaiser's Impact Magnus Line Ups.", function(k)
	if k then
		StarterGui:SetCore("SendNotification", {
			Title = "Kaiser Line Ups",
			Text = "Enabled.",
			Duration = 3
		})

		pad(Vector3.new(-538, -1, 1097), Color3.fromRGB(255, 0, 0))
		target(Vector3.new(-526, 121, 844), Color3.fromRGB(255, 0, 0))

		pad(Vector3.new(-414, -1, 1049), Color3.fromRGB(0, 255, 0))
		target(Vector3.new(-485, 84, 843), Color3.fromRGB(0, 255, 0))

		pad(Vector3.new(-304, -1, 896), Color3.fromRGB(255, 255, 0))
		target(Vector3.new(-418, 48, 849), Color3.fromRGB(255, 255, 0))

		pad(Vector3.new(-327, -1, 843), Color3.fromRGB(0, 0, 255))
		target(Vector3.new(-443, 38, 816), Color3.fromRGB(0, 0, 255))

		pad(Vector3.new(-495, -1, 945), Color3.fromRGB(255, 0, 255))
		target(Vector3.new(-510, 19, 841), Color3.fromRGB(255, 0, 255))

		pad(Vector3.new(-669, -1, 976), Color3.fromRGB(255, 182, 193))
		target(Vector3.new(-447, 66, 847), Color3.fromRGB(255, 182, 193))

		pad(Vector3.new(-536, -1, 1469), Color3.fromRGB(255, 0, 0))
		target(Vector3.new(-547, 125, 1706), Color3.fromRGB(255, 0, 0))

		pad(Vector3.new(-766, -1, 1659), Color3.fromRGB(0, 255, 0))
		target(Vector3.new(-677, 34, 1697), Color3.fromRGB(0, 255, 0))

		pad(Vector3.new(-655, -1, 1504), Color3.fromRGB(255, 255, 0))
		target(Vector3.new(-588, 75, 1701), Color3.fromRGB(255, 255, 0))

		pad(Vector3.new(-747, -1, 1704), Color3.fromRGB(0, 0, 255))
		target(Vector3.new(-624, 43, 1732), Color3.fromRGB(0, 0, 255))

		pad(Vector3.new(-583, -1, 1603), Color3.fromRGB(255, 0, 255))
		target(Vector3.new(-559, 18, 1706), Color3.fromRGB(255, 0, 255))

		pad(Vector3.new(-408, -1, 1573), Color3.fromRGB(255, 182, 193))
		target(Vector3.new(-644, 70, 1705), Color3.fromRGB(255, 182, 193))

	else
		StarterGui:SetCore("SendNotification", {
			Title = "Kaiser Line Ups",
			Text = "Disabled.",
			Duration = 3
		})

		for i = 1, padCount do
			local p = Workspace:FindFirstChild("pad" .. i)
			if p then p:Destroy() end
		end

		for i = 1, targetCount do
			local t = Workspace:FindFirstChild("target" .. i)
			if t then t:Destroy() end
		end

		padCount = 0
		targetCount = 0
	end
end)

local autopos = maintab2:Folder("Auto Position Features.", Color3.fromRGB(24, 255, 228), true)

autopos:Label("Auto Position: Automatically Sets Certain Positions.")

_G.AutoToggles = _G.AutoToggles or {
	CF = false,
	GK = false,
	CFConn = nil,
	GKConn = nil
}

buffer = buffer or {
	fromstring = function(str)
		return str
	end
}

function _G.firePacketsIfNear()
	local char = game:GetService("Players").LocalPlayer.Character
	if not char then return end
	local root = char:FindFirstChild("HumanoidRootPart")
	if not root then return end

	if (root.Position - Vector3.new(-260, 4, -1474)).Magnitude <= 15 or
	   (root.Position - Vector3.new(-262, 4, -1722)).Magnitude <= 15 then
		game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\006\001\001\000A"))
		game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\006\001\001\000B"))
	end
end

function _G.fireGKPackets()
	local char = game:GetService("Players").LocalPlayer.Character
	if not char then return end
	local root = char:FindFirstChild("HumanoidRootPart")
	if not root then return end

	game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\006\005\001\000B"))
	game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\006\005\001\000A"))
end

autopos:Toggle("Auto Pick CF", "Automatically Picks Center Field Position On Respawn Or Enable.", function()
	_G.AutoToggles.CF = not _G.AutoToggles.CF

	game:GetService("StarterGui"):SetCore("SendNotification", {
		Title = "Auto Pick CF",
		Text = _G.AutoToggles.CF and "Enabled." or "Disabled.",
		Duration = 1
	})

	if _G.AutoToggles.CF then
		_G.AutoToggles.CFConn = game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function()
			task.wait(1)
			_G.firePacketsIfNear()
		end)

		task.spawn(function()
			repeat task.wait() until game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
			_G.firePacketsIfNear()
		end)
	else
		if _G.AutoToggles.CFConn then
			_G.AutoToggles.CFConn:Disconnect()
			_G.AutoToggles.CFConn = nil
		end
	end
end)

autopos:Toggle("Auto Pick GK", "Automatically Picks Goalkeeper Position On Respawn Or Enable.", function()
	_G.AutoToggles.GK = not _G.AutoToggles.GK

	game:GetService("StarterGui"):SetCore("SendNotification", {
		Title = "Auto Pick GK",
		Text = _G.AutoToggles.GK and "Enabled." or "Disabled.",
		Duration = 1
	})

	if _G.AutoToggles.GK then
		_G.AutoToggles.GKConn = game:GetService("Players").LocalPlayer.CharacterAdded:Connect(function()
			task.wait(1)
			_G.fireGKPackets()
		end)

		task.spawn(function()
			repeat task.wait() until game:GetService("Players").LocalPlayer.Character and game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
			_G.fireGKPackets()
		end)
	else
		if _G.AutoToggles.GKConn then
			_G.AutoToggles.GKConn:Disconnect()
			_G.AutoToggles.GKConn = nil
		end
	end
end)

local autogk = maintab2:Folder("Auto Goalkeeper Features.", Color3.fromRGB(24, 255, 228), true)

autogk:Label("Auto Goalkeeper: Automatically Plays As GK For You.")

autogk:Button("Celeron's Auto GK (V1, Silent.)", "Automatically Attempts To Block Shots By Opponents, Reset Or Click F4 To Disable.", function()
    getgenv().agk_plr = Players.LocalPlayer
    getgenv().agk_char = getgenv().agk_plr.Character or getgenv().agk_plr.CharacterAdded:Wait()
    getgenv().agk_hum = getgenv().agk_char:WaitForChild("Humanoid")
    getgenv().agk_hrp = getgenv().agk_char:WaitForChild("HumanoidRootPart")

    getgenv().agk_guii = Instance.new("ScreenGui")
    getgenv().agk_guii.Parent = getgenv().agk_plr.PlayerGui

    getgenv().agk_dot = Instance.new("Frame")
    getgenv().agk_dot.Size = UDim2.new(0.012,0,0.025,0)
    getgenv().agk_dot.Position = UDim2.new(0.988,0,0.975,0)
    getgenv().agk_dot.BackgroundColor3 = Color3.fromRGB(0,255,0)
    getgenv().agk_dot.BorderSizePixel = 0
    getgenv().agk_dot.Parent = getgenv().agk_guii

    getgenv().agk_onn = true
    getgenv().agk_pause = false

    getgenv().agk_hum.AutoRotate = false

    getgenv().agk_look = Instance.new("AlignOrientation")
    getgenv().agk_look.Mode = Enum.OrientationAlignmentMode.OneAttachment
    getgenv().agk_look.Attachment0 = getgenv().agk_hrp:WaitForChild("RootAttachment")
    getgenv().agk_look.Responsiveness = 1200
    getgenv().agk_look.MaxTorque = math.huge
    getgenv().agk_look.Enabled = false
    getgenv().agk_look.Parent = getgenv().agk_hrp

    getgenv().agk_ballHolder = ReplicatedStorage.workspace.ballHolder
    getgenv().agk_lastHolder = getgenv().agk_ballHolder.Value

    getgenv().agk_ballHolder.Changed:Connect(function()
        local cur = getgenv().agk_ballHolder.Value
        if getgenv().agk_lastHolder == getgenv().agk_char and cur == nil then
            getgenv().agk_pause = true
            task.delay(0.3, function()
                getgenv().agk_pause = false
            end)
        end
        getgenv().agk_lastHolder = cur
    end)

    getgenv().agk_remote = ReplicatedStorage:WaitForChild("ByteNetReliable")
    getgenv().agk_map = Workspace:WaitForChild("map")
    getgenv().agk_GRAVITY = Vector3.new(0, -Workspace.Gravity, 0)

    local function getBall()
        return Workspace.Terrain:FindFirstChild("Ball")
    end

    local function getTeamGoal()
        if getgenv().agk_plr.Team == game.Teams.B then
            return getgenv().agk_map.Bgoal
        elseif getgenv().agk_plr.Team == game.Teams.A then
            return getgenv().agk_map.Agoal
        end
    end

    local function predictGoalImpact(pos, vel, accel, goal)
        if not goal then return nil end
        local cf = goal.CFrame
        local normal = cf.LookVector
        local goalPos = cf.Position
        local rel = pos - goalPos
        local a = 0.5 * accel:Dot(normal)
        local b = vel:Dot(normal)
        local c = rel:Dot(normal)
        if math.abs(a) < 1e-6 then
            if math.abs(b) < 1e-6 then return nil end
            local t = -c / b
            return t > 0 and t or nil
        end
        local disc = b*b - 4*a*c
        if disc < 0 then return nil end
        local sqrtDisc = math.sqrt(disc)
        local t1 = (-b - sqrtDisc) / (2*a)
        local t2 = (-b + sqrtDisc) / (2*a)
        local t
        if t1 > 0 then t = t1 end
        if t2 > 0 and (not t or t2 < t) then t = t2 end
        if not t then return nil end
        local impactPos = pos + vel * t + 0.5 * accel * t * t
        return impactPos
    end

    getgenv().agk_velSmooth = Vector3.zero
    getgenv().agk_lastVel = Vector3.zero

    getgenv().agk_conn = RunService.RenderStepped:Connect(function(dt)
        if not getgenv().agk_onn then
            getgenv().agk_conn:Disconnect()
            return
        end
        local ball = getBall()
        if not ball or getgenv().agk_plr.Team == game.Teams.lobby or getgenv().agk_pause then
            getgenv().agk_look.Enabled = false
            return
        end

        local rawVel = ball.AssemblyLinearVelocity
        getgenv().agk_velSmooth = getgenv().agk_velSmooth:Lerp(rawVel, math.clamp(dt * 15, 0, 1))
        local accel = (getgenv().agk_velSmooth - getgenv().agk_lastVel) / math.max(dt, 1/240)
        getgenv().agk_lastVel = getgenv().agk_velSmooth

        local goal = getTeamGoal()
        local predictedPos = nil
        local impactTime = predictGoalImpact(ball.Position, getgenv().agk_velSmooth, accel + getgenv().agk_GRAVITY, goal)
        if impactTime then
            predictedPos = ball.Position + getgenv().agk_velSmooth * impactTime + 0.5 * (accel + getgenv().agk_GRAVITY) * impactTime * impactTime
        else
            predictedPos = ball.Position + getgenv().agk_velSmooth * 0.25 + 0.5 * getgenv().agk_GRAVITY * 0.25^2
        end

        getgenv().agk_look.Enabled = true
        getgenv().agk_look.CFrame = CFrame.lookAt(getgenv().agk_hrp.Position, Vector3.new(predictedPos.X, getgenv().agk_hrp.Position.Y, predictedPos.Z))

        local dist = (getgenv().agk_hrp.Position - ball.Position).Magnitude

        local jumpTriggered = false
        local steps = 20
        for i = 0, steps do
            local t = i / steps * math.min(0.5, dist/60)
            local point = ball.Position + getgenv().agk_velSmooth * t + 0.5 * (accel + getgenv().agk_GRAVITY) * t * t
            if (point.Y > getgenv().agk_hrp.Position.Y) and ((point - getgenv().agk_hrp.Position).Magnitude <= 65) then
                jumpTriggered = true
                break
            end
        end

        if jumpTriggered then
            getgenv().agk_hum.Jump = true
            local moveDir = (Vector3.new(predictedPos.X, getgenv().agk_hrp.Position.Y, predictedPos.Z) - getgenv().agk_hrp.Position).Unit
            getgenv().agk_hrp.Velocity = moveDir * 90 + Vector3.new(0, getgenv().agk_hrp.Velocity.Y, 0)
        end

        if dist <= 65 then
            getgenv().agk_remote:FireServer(buffer.fromstring(buffers["base"]), {{ "tackle" }})
        end
    end)

    getgenv().agk_disable = UserInputService.InputBegan:Connect(function(input, gp)
        if gp then return end
        if input.KeyCode == Enum.KeyCode.F4 then
            getgenv().agk_onn = false
            getgenv().agk_look:Destroy()
            getgenv().agk_disable:Disconnect()
            getgenv().agk_conn:Disconnect()
            if getgenv().agk_guii then getgenv().agk_guii:Destroy() end
        end
    end)

    repeat task.wait() until getgenv().agk_hum.Health <= 0 or getgenv().agk_plr.Team == game.Teams.lobby
    getgenv().agk_onn = false
    getgenv().agk_look:Destroy()
    getgenv().agk_disable:Disconnect()
    getgenv().agk_conn:Disconnect()
    if getgenv().agk_guii then getgenv().agk_guii:Destroy() end
end)

autogk:Button("Celeron's Auto GK (V2, Semi-Blatant.)", "Automatically Attempts To Block Shots By Opponents, Reset Or Click F4 To Disable.", function()
    getgenv().agk_plr = Players.LocalPlayer
    getgenv().agk_char = getgenv().agk_plr.Character or getgenv().agk_plr.CharacterAdded:Wait()
    getgenv().agk_hum = getgenv().agk_char:WaitForChild("Humanoid")
    getgenv().agk_hrp = getgenv().agk_char:WaitForChild("HumanoidRootPart")

    getgenv().agk_guii = Instance.new("ScreenGui")
    getgenv().agk_guii.Parent = getgenv().agk_plr.PlayerGui

    getgenv().agk_dot = Instance.new("Frame")
    getgenv().agk_dot.Size = UDim2.new(0.012,0,0.025,0)
    getgenv().agk_dot.Position = UDim2.new(0.988,0,0.975,0)
    getgenv().agk_dot.BackgroundColor3 = Color3.fromRGB(0,255,0)
    getgenv().agk_dot.BorderSizePixel = 0
    getgenv().agk_dot.Parent = getgenv().agk_guii

    getgenv().agk_onn = true
    getgenv().agk_pause = false

    getgenv().agk_hum.AutoRotate = false

    getgenv().agk_look = Instance.new("AlignOrientation")
    getgenv().agk_look.Mode = Enum.OrientationAlignmentMode.OneAttachment
    getgenv().agk_look.Attachment0 = getgenv().agk_hrp:WaitForChild("RootAttachment")
    getgenv().agk_look.Responsiveness = 1200
    getgenv().agk_look.MaxTorque = math.huge
    getgenv().agk_look.Enabled = false
    getgenv().agk_look.Parent = getgenv().agk_hrp

    getgenv().agk_ballHolder = ReplicatedStorage.workspace.ballHolder
    getgenv().agk_lastHolder = getgenv().agk_ballHolder.Value

    getgenv().agk_ballHolder.Changed:Connect(function()
        local cur = getgenv().agk_ballHolder.Value
        if getgenv().agk_lastHolder == getgenv().agk_char and cur == nil then
            getgenv().agk_pause = true
            task.delay(0.3, function()
                getgenv().agk_pause = false
            end)
        end
        getgenv().agk_lastHolder = cur
    end)

    getgenv().agk_remote = ReplicatedStorage:WaitForChild("ByteNetReliable")
    getgenv().agk_map = Workspace:WaitForChild("map")
    getgenv().agk_GRAVITY = Vector3.new(0, -Workspace.Gravity, 0)

    local function getBall()
        return Workspace.Terrain:FindFirstChild("Ball")
    end

    local function getTeamGoal()
        if getgenv().agk_plr.Team == game.Teams.B then
            return getgenv().agk_map.Bgoal
        elseif getgenv().agk_plr.Team == game.Teams.A then
            return getgenv().agk_map.Agoal
        end
    end

    local function predictGoalImpact(pos, vel, accel, goal)
        if not goal then return nil end
        local cf = goal.CFrame
        local normal = cf.LookVector
        local goalPos = cf.Position
        local rel = pos - goalPos
        local a = 0.5 * accel:Dot(normal)
        local b = vel:Dot(normal)
        local c = rel:Dot(normal)
        if math.abs(a) < 1e-6 then
            if math.abs(b) < 1e-6 then return nil end
            local t = -c / b
            return t > 0 and t or nil
        end
        local disc = b*b - 4*a*c
        if disc < 0 then return nil end
        local sqrtDisc = math.sqrt(disc)
        local t1 = (-b - sqrtDisc) / (2*a)
        local t2 = (-b + sqrtDisc) / (2*a)
        local t
        if t1 > 0 then t = t1 end
        if t2 > 0 and (not t or t2 < t) then t = t2 end
        if not t then return nil end
        local impactPos = pos + vel * t + 0.5 * accel * t * t
        return impactPos
    end

    getgenv().agk_velSmooth = Vector3.zero
    getgenv().agk_lastVel = Vector3.zero

    getgenv().agk_conn = RunService.RenderStepped:Connect(function(dt)
        if not getgenv().agk_onn then
            getgenv().agk_conn:Disconnect()
            return
        end

        local ball = getBall()
        if not ball or getgenv().agk_plr.Team == game.Teams.lobby or getgenv().agk_pause then
            getgenv().agk_look.Enabled = false
            return
        end

        local rawVel = ball.AssemblyLinearVelocity
        getgenv().agk_velSmooth = getgenv().agk_velSmooth:Lerp(rawVel, math.clamp(dt * 15, 0, 1))
        local accel = (getgenv().agk_velSmooth - getgenv().agk_lastVel) / math.max(dt, 1/240)
        getgenv().agk_lastVel = getgenv().agk_velSmooth

        local goal = getTeamGoal()
        local impactTime = predictGoalImpact(ball.Position, getgenv().agk_velSmooth, accel + getgenv().agk_GRAVITY, goal)

        local predictedPos
        if impactTime then
            predictedPos = ball.Position + getgenv().agk_velSmooth * impactTime + 0.5 * (accel + getgenv().agk_GRAVITY) * impactTime * impactTime
        else
            predictedPos = ball.Position + getgenv().agk_velSmooth * 0.25 + 0.5 * getgenv().agk_GRAVITY * 0.25^2
        end

        getgenv().agk_look.Enabled = true
        getgenv().agk_look.CFrame = CFrame.lookAt(
            getgenv().agk_hrp.Position,
            Vector3.new(predictedPos.X, getgenv().agk_hrp.Position.Y, predictedPos.Z)
        )

        local dist = (getgenv().agk_hrp.Position - ball.Position).Magnitude

        if dist <= 14.5 then
            getgenv().agk_remote:FireServer(buffer.fromstring(buffers["grabball"]))
        end

        local jumpTriggered = false
        local steps = 20
        for i = 0, steps do
            local t = i / steps * math.min(0.5, dist / 60)
            local point = ball.Position + getgenv().agk_velSmooth * t + 0.5 * (accel + getgenv().agk_GRAVITY) * t * t
            if point.Y > getgenv().agk_hrp.Position.Y and (point - getgenv().agk_hrp.Position).Magnitude <= 65 then
                jumpTriggered = true
                break
            end
        end

        if jumpTriggered then
            getgenv().agk_hum.Jump = true
            local moveDir = (Vector3.new(predictedPos.X, getgenv().agk_hrp.Position.Y, predictedPos.Z) - getgenv().agk_hrp.Position).Unit
            getgenv().agk_hrp.Velocity = moveDir * 90 + Vector3.new(0, getgenv().agk_hrp.Velocity.Y, 0)
        end

        if dist <= 65 then
            getgenv().agk_remote:FireServer(buffer.fromstring(buffers["base"]), {{ "tackle" }})
        end
    end)

    getgenv().agk_disable = UserInputService.InputBegan:Connect(function(input, gp)
        if gp then return end
        if input.KeyCode == Enum.KeyCode.F4 then
            getgenv().agk_onn = false
            getgenv().agk_look:Destroy()
            getgenv().agk_disable:Disconnect()
            getgenv().agk_conn:Disconnect()
            if getgenv().agk_guii then getgenv().agk_guii:Destroy() end
        end
    end)

    repeat task.wait() until getgenv().agk_hum.Health <= 0 or getgenv().agk_plr.Team == game.Teams.lobby
    getgenv().agk_onn = false
    getgenv().agk_look:Destroy()
    getgenv().agk_disable:Disconnect()
    getgenv().agk_conn:Disconnect()
    if getgenv().agk_guii then getgenv().agk_guii:Destroy() end
end)

autogk:Button("Daffy's Auto GK", "Automatically Attempts To Block Shots By Opponents, Reset Or Click F4 To Disable.", function()
    getgenv().agk_plr = Players.LocalPlayer
    getgenv().agk_char = getgenv().agk_plr.Character or getgenv().agk_plr.CharacterAdded:Wait()
    getgenv().agk_cam = workspace.CurrentCamera
    getgenv().agk_hum = getgenv().agk_char:WaitForChild("Humanoid")
    getgenv().agk_hrp = getgenv().agk_char:WaitForChild("HumanoidRootPart")

    getgenv().agk_originalCamType = getgenv().agk_cam.CameraType
    getgenv().agk_originalCamCFrame = getgenv().agk_cam.CFrame

    getgenv().agk_guii = Instance.new("ScreenGui")
    getgenv().agk_guii.Parent = getgenv().agk_plr.PlayerGui

    getgenv().agk_cambu = Instance.new("TextButton")
    getgenv().agk_cambu.Text = "Camera Mode"
    getgenv().agk_cambu.Size = UDim2.new(0.159,0,0.109,0)
    getgenv().agk_cambu.Position = UDim2.new(0.317,0,0.444,0)
    getgenv().agk_cambu.TextScaled = true
    getgenv().agk_cambu.Parent = getgenv().agk_guii

    getgenv().agk_gerg = Instance.new("TextButton")
    getgenv().agk_gerg.Text = "Body Mode"
    getgenv().agk_gerg.Size = UDim2.new(0.159,0,0.109,0)
    getgenv().agk_gerg.Position = UDim2.new(0.524,0,0.444,0)
    getgenv().agk_gerg.TextScaled = true
    getgenv().agk_gerg.Parent = getgenv().agk_guii

    getgenv().agk_dot = Instance.new("Frame")
    getgenv().agk_dot.Size = UDim2.new(0.012,0,0.025,0)
    getgenv().agk_dot.Position = UDim2.new(0.988,0,0.975,0)
    getgenv().agk_dot.BackgroundColor3 = Color3.fromRGB(0,255,0)
    getgenv().agk_dot.BorderSizePixel = 0
    getgenv().agk_dot.Parent = getgenv().agk_guii

    getgenv().agk_kind = ""
    getgenv().agk_cambu.MouseButton1Up:Connect(function()
        getgenv().agk_kind = "cam"
    end)
    getgenv().agk_gerg.MouseButton1Up:Connect(function()
        getgenv().agk_kind = "body"
    end)

    repeat task.wait() until getgenv().agk_kind ~= ""
    getgenv().agk_cambu:Destroy()
    getgenv().agk_gerg:Destroy()

    local function getBall()
        return workspace.Terrain:FindFirstChild("Ball")
    end

    getgenv().agk_align = nil
    if getgenv().agk_kind == "body" then
        getgenv().agk_hum.AutoRotate = false
        getgenv().agk_align = Instance.new("AlignOrientation")
        getgenv().agk_align.Mode = Enum.OrientationAlignmentMode.OneAttachment
        getgenv().agk_align.Attachment0 = getgenv().agk_hrp:WaitForChild("RootAttachment")
        getgenv().agk_align.Responsiveness = 300
        getgenv().agk_align.MaxTorque = math.huge
        getgenv().agk_align.Enabled = false
        getgenv().agk_align.Parent = getgenv().agk_hrp
    end

    getgenv().agk_onn = true
    getgenv().agk_pause = false

    getgenv().agk_ballHolder = ReplicatedStorage.workspace.ballHolder
    getgenv().agk_lastHolder = getgenv().agk_ballHolder.Value

    getgenv().agk_ballHolder.Changed:Connect(function()
        local cur = getgenv().agk_ballHolder.Value
        if getgenv().agk_lastHolder == getgenv().agk_char and cur == nil then
            getgenv().agk_pause = true
            task.delay(0.7, function()
                getgenv().agk_pause = false
            end)
        end
        getgenv().agk_lastHolder = cur
    end)

    getgenv().agk_remote = ReplicatedStorage:WaitForChild("ByteNetReliable")

    local function cleanup()
        getgenv().agk_onn = false

        if getgenv().agk_align then
            getgenv().agk_align:Destroy()
        end

        getgenv().agk_cam.CameraType = getgenv().agk_originalCamType
        getgenv().agk_cam.CFrame = getgenv().agk_originalCamCFrame

        if getgenv().agk_guii then
            getgenv().agk_guii:Destroy()
        end
    end

    getgenv().agk_con = RunService.RenderStepped:Connect(function()
        if not getgenv().agk_onn then
            getgenv().agk_con:Disconnect()
            return
        end

        local ball = getBall()
        if not ball or getgenv().agk_plr.Team == game.Teams.lobby or getgenv().agk_pause then
            if getgenv().agk_align then getgenv().agk_align.Enabled = false end
            return
        end

        if getgenv().agk_kind == "cam" then
            getgenv().agk_cam.CameraType = Enum.CameraType.Scriptable
            getgenv().agk_cam.CFrame = CFrame.lookAt(getgenv().agk_cam.CFrame.Position, ball.Position)

        elseif getgenv().agk_kind == "body" then
            getgenv().agk_align.Enabled = true
            local dir = ball.Position - getgenv().agk_hrp.Position
            dir = Vector3.new(dir.X, 0, dir.Z)
            if dir.Magnitude > 0.01 then
                getgenv().agk_align.CFrame = CFrame.lookAt(Vector3.zero, dir)
            end
        end

        local dist = (getgenv().agk_hrp.Position - ball.Position).Magnitude
        if dist <= 60 then
            if ball.Position.Y >= getgenv().agk_hrp.Position.Y + 6 then
                getgenv().agk_hum.Jump = true
            else
                getgenv().agk_hum.Jump = false
            end

            getgenv().agk_remote:FireServer(
                buffer.fromstring(buffers.base),
                {
                    { "tackle" }
                }
            )
        end
    end)

    getgenv().agk_kill = UserInputService.InputBegan:Connect(function(input, gp)
        if gp then return end
        if input.KeyCode == Enum.KeyCode.F4 then
            cleanup()
            getgenv().agk_kill:Disconnect()
            getgenv().agk_con:Disconnect()
        end
    end)

    repeat task.wait() until getgenv().agk_hum.Health <= 0 or getgenv().agk_plr.Team == game.Teams.lobby
    cleanup()
    getgenv().agk_kill:Disconnect()
    getgenv().agk_con:Disconnect()
end)

local othersil = maintab2:Folder("Other Silent Features.", Color3.fromRGB(24, 255, 228), true)

othersil:Label("Other Features: Self Explanatory, Other Silent Features.")

local remote = game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable")
local UIS = game:GetService("UserInputService")
local StarterGui = game:GetService("StarterGui")

local airDribbleEnabled = false

othersil:Toggle("Air Dribble (Bind: LeftAlt)", "Kicks The Ball Forward Infront Of You And Up On LeftAlt Click.", function()
    airDribbleEnabled = not airDribbleEnabled
    StarterGui:SetCore("SendNotification", {
        Title = "Air Dribble",
        Text = airDribbleEnabled and "Enabled." or "Disabled.",
        Duration = 2
    })
end)

UIS.InputBegan:Connect(function(input, gp)
    if gp or input.KeyCode ~= Enum.KeyCode.LeftAlt then return end
    if not airDribbleEnabled then return end
    local char = game.Players.LocalPlayer.Character
    local hum = char and char:FindFirstChildOfClass("Humanoid")
    local root = char and char:FindFirstChild("HumanoidRootPart")
    if not (hum and root) then return end
    local anim = Instance.new("Animation")
    anim.AnimationId = "rbxassetid://76587445975710"
    local track = hum:LoadAnimation(anim)
    track:Play()
    local dir = root.CFrame.LookVector
    local kickVec = vector.create(dir.X * 0.75, 0.65, dir.Z * 0.75)
    remote:FireServer(buffer.fromstring(buffers["base"]), { { "kick", 28, false, kickVec } })
end)

othersil:Toggle("Auto QuickTimeEvent", "Automatically Does QuickTimeEvents, How Else Can I Explain It?", function()
    local runService = game:GetService("RunService")
    local players = game:GetService("Players")
    local virtualInputManager = game:GetService("VirtualInputManager")
    local starterGui = game:GetService("StarterGui")
    local player = players.LocalPlayer

    _G.QuickTimeEvent = not _G.QuickTimeEvent

    local function sendNotification(status)
        if not _G.suppressNotifs then
            starterGui:SetCore("SendNotification", {
                Title = "QuickTimeEvent",
                Text = status,
                Duration = 1
            })
        end
    end

    local function convertNumberToKeyText(text)
        local numberMap = {
            ["1"] = "One", ["2"] = "Two", ["3"] = "Three", ["4"] = "Four", ["5"] = "Five",
            ["6"] = "Six", ["7"] = "Seven", ["8"] = "Eight", ["9"] = "Nine", ["0"] = "Zero"
        }
        return numberMap[text] or text
    end

    local function isShadeOfGreen(color)
        return color.G > color.R and color.G > color.B
    end

    local function checkQTE()
        if _G.QuickTimeEvent and player and player:FindFirstChild("PlayerGui") then
            local qteGui = player.PlayerGui:FindFirstChild("Qte")
            if qteGui and qteGui:FindFirstChild("QTE") then
                for _, descendant in ipairs(qteGui.QTE:GetDescendants()) do
                    if descendant:IsA("Frame") or descendant:IsA("TextLabel") then
                        if isShadeOfGreen(descendant.BackgroundColor3) then
                            local textLabel = qteGui.QTE:FindFirstChild("TextLabel")
                            if textLabel then
                                local keyText = convertNumberToKeyText(textLabel.Text)
                                local keyCode = Enum.KeyCode[keyText]
                                if keyCode then
                                    virtualInputManager:SendKeyEvent(true, keyCode, false, game)
                                    virtualInputManager:SendKeyEvent(false, keyCode, false, game)
                                end
                            end
                            break
                        end
                    end
                end
            end
        end
    end

    runService.RenderStepped:Connect(checkQTE)

    sendNotification(_G.QuickTimeEvent and "Enabled." or "Disabled.")
end)

othersil:Toggle("Auto Formless (Bind: Y)", "Shidou Only Formless Macro.", function()
    local UIS = game:GetService("UserInputService")
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local StarterGui = game:GetService("StarterGui")
    local Camera = workspace.CurrentCamera
    local LP = Players.LocalPlayer
    local ByteNetReliable = ReplicatedStorage:WaitForChild("ByteNetReliable")

    _G.autoFormlessEnabled = not (_G.autoFormlessEnabled or false)

    if not _G.suppressNotifs then
        StarterGui:SetCore("SendNotification", {
            Title = "Auto Formless",
            Text = _G.autoFormlessEnabled and "Enabled." or "Disabled.",
            Duration = 2
        })
    end

    if not _G.autoFormlessEnabled then return end

    UIS.InputBegan:Connect(function(input, gp)
        if not _G.autoFormlessEnabled or gp or input.KeyCode ~= Enum.KeyCode.Y or UIS.MouseBehavior ~= Enum.MouseBehavior.LockCenter then return end

        local char = LP.Character
        local hrp = char and char:FindFirstChild("HumanoidRootPart")
        local hum = char and char:FindFirstChildOfClass("Humanoid")
        if not hrp or not hum then return end

        hum.AutoRotate = false

        local camType = Camera.CameraType
        local camSubject = Camera.CameraSubject
        local camCF = Camera.CFrame
        local flipped = camCF * CFrame.Angles(0, math.rad(180), 0)

        Camera.CameraType = Enum.CameraType.Scriptable
        Camera.CFrame = flipped

        task.delay(0.1, function()
            if LP.Character and LP.Character:FindFirstChildOfClass("Humanoid") then
                Camera.CameraSubject = LP.Character:FindFirstChildOfClass("Humanoid")
                Camera.CameraType = Enum.CameraType.Custom
            else
                Camera.CameraSubject = camSubject
                Camera.CameraType = camType
            end
            hum.AutoRotate = true
        end)

        task.wait(0.15)

        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://76587445975710"
        local track = hum:LoadAnimation(anim)
        track:Play()

        local dir = hrp.CFrame.LookVector
        local kickVec = vector.create(dir.X * 0.5, 1, dir.Z * 0.5)

        remote:FireServer(buffer.fromstring(buffers["base"]), { { "kick", 25, false, kickVec } })

        ByteNetReliable:FireServer(
            buffer.fromstring(buffers["base"]),
            { { "skill1" } }
        )
    end)
end)

_G.nocutscene = false

othersil:Toggle("No Cutscene", "Shitty Feature For Right Now That Disables Cutscenes.", function()
    _G.nocutscene = not _G.nocutscene
    local StarterGui = game:GetService("StarterGui")
    local SoundService = game:GetService("SoundService")
    local tempFolder = SoundService:FindFirstChild("celerontemp") or Instance.new("Folder", SoundService)
    tempFolder.Name = "celerontemp"
    local crowdSound = SoundService:FindFirstChild("football-crowd-3-69245") or tempFolder:FindFirstChild("football-crowd-3-69245")

    StarterGui:SetCore("SendNotification", {
        Title = "No Cutscene",
        Text = _G.nocutscene and "Enabled." or "Disabled.",
        Duration = 1
    })

    if _G.nocutscene then
        if crowdSound and crowdSound:IsDescendantOf(SoundService) then
            local clone = crowdSound:Clone()
            clone.Parent = tempFolder
            crowdSound:Stop()
            crowdSound:Destroy()
        end
    else
        local stored = tempFolder:FindFirstChild("football-crowd-3-69245")
        if stored then
            stored.Parent = SoundService
            stored:Play()
        end
    end
end)

local iframeIndicatorEnabled = false
local activeDots = {}
local dotSize = UDim2.new(0, 6, 0, 6)
local offset = Vector3.new(0, 3, 0)
local updateInterval = 0.2

othersil:Toggle("IFrame Indicator", "Shows The I-Frame Status Of All Players. (Green = Off, Red = On.)", function()
    iframeIndicatorEnabled = not iframeIndicatorEnabled

    local StarterGui = game:GetService("StarterGui")
    StarterGui:SetCore("SendNotification", {
        Title = "IFrame Indicator",
        Text = iframeIndicatorEnabled and "Enabled." or "Disabled.",
        Duration = 3
    })

    local charactersFolder = workspace:FindFirstChild("characters")
    if not charactersFolder then return end

    local function createDot(char)
        if activeDots[char] then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local gui = Instance.new("BillboardGui")
        gui.Name = "IframeDot"
        gui.Size = UDim2.new(0, 12, 0, 12)
        gui.StudsOffset = offset
        gui.AlwaysOnTop = true
        gui.Adornee = hrp
        gui.Parent = hrp
        local dot = Instance.new("Frame")
        dot.Size = dotSize
        dot.Position = UDim2.new(0.5, -3, 0.5, -3)
        dot.BackgroundColor3 = Color3.fromRGB(128, 128, 128)
        dot.BorderSizePixel = 0
        dot.BackgroundTransparency = 0
        dot.Parent = gui
        activeDots[char] = dot
    end

    local function updateDot(char, dot)
        local state = char:FindFirstChild("state")
        local iframe = state and state:FindFirstChild("iframe")
        if iframe and iframe:IsA("BoolValue") then
            dot.BackgroundColor3 = iframe.Value and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(0, 255, 0)
        else
            dot.BackgroundColor3 = Color3.fromRGB(128, 128, 128)
        end
    end

    local function clearDots()
        for char, dot in pairs(activeDots) do
            if dot and dot.Parent then
                dot.Parent:Destroy()
            end
        end
        activeDots = {}
    end

    if iframeIndicatorEnabled then
        for _, char in ipairs(charactersFolder:GetChildren()) do
            createDot(char)
        end
        charactersFolder.ChildAdded:Connect(function(char)
            task.wait(0.5)
            if iframeIndicatorEnabled then
                createDot(char)
            end
        end)
        task.spawn(function()
            while iframeIndicatorEnabled do
                for char, dot in pairs(activeDots) do
                    if char and dot then
                        updateDot(char, dot)
                    end
                end
                for _, char in ipairs(charactersFolder:GetChildren()) do
                    if not activeDots[char] then
                        createDot(char)
                    end
                end
                task.wait(updateInterval)
            end
        end)
    else
        clearDots()
    end
end)

othersil:Button("Fix Duplicate Ball", "I Don't Know If This Is Still An Issue But Removes Duplicate Balls If Existent.", function()
    for _, obj in ipairs(workspace.Terrain:GetDescendants()) do
        if obj:IsA("MeshPart") and obj.Name == "Ball" then
            obj:Destroy()
        end
    end
end)

funtab:Label("Celeron's Movesets, Recommend Using In Normal Servers.")

funtab:Button("Goku Moveset (Req. Isagi)", function()
local StarterGui = game:GetService("StarterGui")
StarterGui:SetCore("SendNotification", {
    Title = "Credits",
    Text = "brought to you by celeron!",
    Duration = 5,
    Button1 = "OK",
})
loadstring(game:HttpGet("https://raw.githubusercontent.com/ghostofcelleron/Celeron/refs/heads/main/goku%20moveset%20(azl)",true))()
end)

funtab:Button("Aizen Moveset (Req. Isagi, Early Access.)", function()
local StarterGui = game:GetService("StarterGui")
StarterGui:SetCore("SendNotification", {
    Title = "Credits",
    Text = "brought to you by celeron!",
    Duration = 5,
    Button1 = "OK",
})
loadstring(game:HttpGet("https://raw.githubusercontent.com/ghostofcelleron/Celeron/refs/heads/main/aizen%20moveset",true))()
end)

funtab:Label("Daffy's Movesets.")
funtab:Button("Ronaldo V2 (Req. Shidou)", function()
local StarterGui = game:GetService("StarterGui")
StarterGui:SetCore("SendNotification", {
    Title = "Credits",
    Text = "brought to you by daffy!",
    Duration = 5,
    Button1 = "OK",
})

local plr = game.Players.LocalPlayer
local rep = game:GetService("ReplicatedStorage")
local initialized = false
local fahh = false

local function ToggleAttachment(attachment, enabled, duration)
	if not attachment then return end
	for _, descendant in ipairs(attachment:GetDescendants()) do
		if descendant:IsA("ParticleEmitter") then
			descendant.Enabled = enabled
		end
	end
	if duration and duration > 0 then
		task.delay(duration, function()
			ToggleAttachment(attachment, false)
		end)
	end
end

local function EmitAttachment(attachment)
	if not attachment then return end
	for _, descendant in ipairs(attachment:GetDescendants()) do
		if descendant:IsA("ParticleEmitter") then
			local delayTime = descendant:GetAttribute("EmitDelay") or 0
			local count = descendant:GetAttribute("EmitCount") or 1
			if delayTime > 0 then
				task.delay(delayTime, function()
					descendant:Emit(count)
				end)
			else
				descendant:Emit(count)
			end
		end
	end
end

local function GroupWeld(model, rootPart)
	for _, part in ipairs(rootPart:GetDescendants()) do
		if part:IsA("BasePart") and model:FindFirstChild(part.Name) then
			local weld = Instance.new("Weld")
			weld.Name = "weld"
			weld.Part0 = model:FindFirstChild(part.Name)
			weld.Part1 = part
			weld.Parent = part
		end
	end
end

local function hasball()
	return plr.Character:FindFirstChild("Ball") ~= nil
end

local function BodyVelocity(part, speed, duration, startAtZero, easingInfo, delayTween, delayStart, useCustomTween)
	for _, v in pairs(part:GetChildren()) do
		if v:IsA("BodyVelocity") then
			v:Destroy()
		end
	end

	local directionProperty = delayTween or "LookVector"
	local bv = Instance.new("BodyVelocity")
	bv.MaxForce = Vector3.new(350000, 0, 350000)
	bv.Parent = part
	task.delay(duration, bv.Destroy, bv)

	local valueHolder = Instance.new("NumberValue")
	valueHolder.Value = startAtZero and 0 or speed
	valueHolder.Parent = bv

	if not useCustomTween then
		local tweenInfo = easingInfo or TweenInfo.new(duration, Enum.EasingStyle.Linear, Enum.EasingDirection.Out)
		local goal = { Value = startAtZero and 0 or speed }
		game.TweenService:Create(valueHolder, tweenInfo, goal):Play()
	else
		task.delay(useCustomTween, function()
			local easingStyle = easingInfo or Enum.EasingStyle.Linear
			local goal = { Value = startAtZero and 0 or speed }
			local tweenInfo = TweenInfo.new(duration, easingStyle, Enum.EasingDirection.Out)
			game.TweenService:Create(valueHolder, tweenInfo, goal):Play()
		end)
	end

	if not delayStart then
		bv.Velocity = part.CFrame[directionProperty] * speed
		local connection
		connection = game["Run Service"].RenderStepped:Connect(function()
			if not bv:IsDescendantOf(game) then
				connection:Disconnect()
				return
			end
			bv.Velocity = part.CFrame[directionProperty] * valueHolder.Value
		end)
	end

	return bv, valueHolder
end

local function sfx(sound:Sound, part:Instance)
	local s = sound:Clone()
	s.Parent = part
	s:Play()
	game.Debris:AddItem(s, s.TimeLength + 20)
end

game.UserInputService.InputBegan:Connect(function(input, bg)
	if bg then return end
	local char = plr.Character
	if input.KeyCode == Enum.KeyCode.Three then
		task.spawn(function()
			char.state.stun.Value = true
			task.wait(0.03)
			char.state.stun.Value = fahh and true or false
		end)

		task.wait(0.03)

		if char.state.stun.Value or not hasball() or fahh then return end

		local root = char:FindFirstChild("HumanoidRootPart") or char.PrimaryPart
		char.state.stun.Value = true
		local loopws = game:GetService("RunService").RenderStepped:Connect(function()
			char.Humanoid.WalkSpeed = 0
		end)
		fahh = true

		task.delay(4.6, function()
			loopws:Disconnect()
			char.Humanoid.WalkSpeed = 40
			char.state.stun.Value = false
			local cooldown = plr.PlayerGui.Hotbar.Backpack.Hotbar.skill3.Cooldown
			cooldown.Size = UDim2.new(1, 0, -1, 0)
			cooldown.Visible = true
			game.TweenService:Create(cooldown, TweenInfo.new(1, Enum.EasingStyle.Linear), {Size = UDim2.new(1, 0, 0, 0)}):Play()
			task.wait(1)
			cooldown.Visible = false
			fahh = false
		end)

		local anim = char.Humanoid:LoadAnimation(rep.Resources.ronaldo.running)
		anim:Play()

		local dribbleClone = rep.Resources.RonaldoDribble:Clone()
		GroupWeld(char, dribbleClone)
		dribbleClone.Parent = workspace.Effects
		sfx(rep.Resources.ronaldo.RonaldoDribble, root)
		game.Debris:AddItem(dribbleClone, 5)

		task.spawn(function()
			task.delay(1.5,  function() BodyVelocity(root,  40, 1   ) end)
			task.delay(1.8,  function() BodyVelocity(root, 120, 1.1 ) end)
			task.delay(2.5,  function() BodyVelocity(root,  90, 0.75) end)
			task.delay(2.9,  function() BodyVelocity(root, 100, 0.85) end)
			task.delay(3.2,  function() BodyVelocity(root, 175, 1.7 ) end)
			task.delay(3.9,  function() BodyVelocity(root,  40, 0.65) end)
		end)

		task.spawn(function()
			local attach = dribbleClone.Rig.Head["1"]
			EmitAttachment(attach)
			ToggleAttachment(attach, true, 1)
		end)

		task.delay(2.5,   function() EmitAttachment(dribbleClone.Rig.HumanoidRootPart["3"]) end)
		task.delay(2.933, function() EmitAttachment(dribbleClone.Rig.HumanoidRootPart["4"]) end)
		task.delay(3.2,   function() EmitAttachment(dribbleClone.Rig.HumanoidRootPart["3.2"]) end)
		task.delay(3.417, function() EmitAttachment(dribbleClone.Rig.HumanoidRootPart["3.5"]) end)
		task.delay(3.933, function() EmitAttachment(dribbleClone.Rig.HumanoidRootPart["5"]) end)

	elseif input.KeyCode == Enum.KeyCode.Two then
		if char.state.stun.Value or not hasball() or plr.PlayerGui.Hotbar.Backpack.Hotbar.skill2.Cooldown.Visible then return end

		local bicycle1 = Instance.new("Animation")
		bicycle1.AnimationId = "rbxassetid://126734456236034"
		local bicycle = char.Humanoid:LoadAnimation(bicycle1)
		bicycle.Priority = Enum.AnimationPriority.Action2
		bicycle:Play()

		sfx(rep.Resources.ronaldo.KICK, char.HumanoidRootPart)

		task.delay(0.8, function()
			local boom = rep.Resources.ronaldo.bicyclekick:Clone()
			boom.Parent = char.HumanoidRootPart
			boom.CFrame = char.HumanoidRootPart.CFrame * CFrame.new(0, 0, -2)
			for _, v in pairs(boom:GetDescendants()) do
				if v:IsA("ParticleEmitter") then
					v:Emit(v:GetAttribute("EmitCount"))
				end
			end
			game.Debris:AddItem(boom, 5)
		end)
	end
end)

local function load(char)
	if initialized then return end
	initialized = true

	repeat task.wait() until plr.Team ~= game.Teams.lobby
	task.wait(0.1)

	local root = char:FindFirstChild("HumanoidRootPart")
	if not root then return end

	plr.PlayerGui.Hotbar.Backpack.Hotbar.skill1.Base.Reuse.Text = ""
	plr.PlayerGui.Hotbar.Backpack.Hotbar.skill3.Base.ToolName.Text = "CR7 Dribble"
	plr.PlayerGui.Hotbar.Backpack.Hotbar.skill2.Base.ToolName.Text = "Bicycle Kick"

	rep.Resources.shidou.NEWthemes.SoundId = "rbxassetid://101265113960897"
	rep.Resources.shidou.NEWshidouUlt.AnimationId = "rbxassetid://101997402253776"
end

load(plr.Character)

plr.CharacterAdded:Connect(function(char)
	task.wait(1)
	load(char)
end)
end)

funtab:Button("Gojo Moveset (Req. Isagi.)", function()
local StarterGui = game:GetService("StarterGui")
StarterGui:SetCore("SendNotification", {
    Title = "Credits",
    Text = "brought to you by daffy!",
    Duration = 5,
    Button1 = "OK",
})
loadstring(game:HttpGet("https://pastebin.com/raw/TH8xDy9X"))()
end)

funtab:Button("Loki Moveset (Req. Isagi.)", function()
local StarterGui = game:GetService("StarterGui")
StarterGui:SetCore("SendNotification", {
    Title = "Credits",
    Text = "brought to you by daffy!",
    Duration = 5,
    Button1 = "OK",
})
loadstring(game:HttpGet("https://pastebin.com/raw/LbRRX7SK"))()
end)

funtab:Button("Lore Sae Moveset (Req. Sae.)", function()
local StarterGui = game:GetService("StarterGui")
StarterGui:SetCore("SendNotification", {
    Title = "Credits",
    Text = "brought to you by daffy!",
    Duration = 5,
    Button1 = "OK",
})
loadstring(game:HttpGet("https://pastebin.com/raw/kMQ0v88u"))()
end)

misctab:Button("Infinite Yield", function()
loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()
end)

teleporttab:Button("Spawn Area", function()
	game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-269, 4, -1599)
end)

teleporttab:Button("Middle Field", function()
	game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-540, 3, 1274)
end)

teleporttab:Button("Gallery Area", function()
	game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(109, 66, 3337)
end)

teleporttab:Button("Goal Box (A)", function()
	game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-537, 3, 1575)
end)

teleporttab:Button("Goal Box (B)", function()
	game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(-534, 3, 974)
end)

misctab:Button("Upgrade UI (very cool actually)", function()
loadstring(game:HttpGet("https://pastebin.com/raw/QDNYsgxQ"))()
end)

misctab:Button("Overtime Cinematics", function()
local vals = game.ReplicatedStorage.workspace
local timer = vals.timer
local ingame = vals.roundstart

local music1Isagi = game:GetService("ReplicatedStorage").Resources.isagi["isagi themeover"]
local music2Sae = game:GetService("ReplicatedStorage").Resources.sae["sae one shot match theme"]

local gui = Instance.new("ScreenGui")
gui.ScreenInsets = Enum.ScreenInsets.None
gui.Name = "overtimethang"
gui.Parent = game.Players.LocalPlayer.PlayerGui

local image = Instance.new("ImageLabel")
image.AnchorPoint = Vector2.new(0.5, 0.5)
image.Position = UDim2.new(0.5, 0,0.5, 0)
image.Size = UDim2.new(1.2, 0,1.2, 0)
image.Image = "rbxassetid://11030033771"
image.ImageTransparency = 0.8
image.BackgroundTransparency = 1
image.Parent = gui

local overtime = false

task.spawn(function()
    while task.wait(0.05) do
        image.Visible = overtime
        
        if overtime == true then
            if game.Workspace.CurrentCamera.CameraType == Enum.CameraType.Custom then
                game.TweenService:Create(game.Workspace.CurrentCamera, TweenInfo.new(0.2), {FieldOfView = 100}):Play()
            end
            
            if image.Rotation == 0 then
                image.Rotation = 180
            else
                image.Rotation = 0
            end
        end
    end
end)

timer.Changed:Connect(function()
    if timer.Value == 0 and ingame.Value == true then
        overtime = true
        
        repeat
            music1Isagi:Play()
            for i = 1, 50 do
                task.wait(1)
                if ingame.Value == false then
                    break
                end
            end
            music2Sae:Play()
            for i = 1, 58 do
                task.wait(1)
                if ingame.Value == false then
                    break
                end
            end
        until ingame.Value == false
        
    elseif ingame.Value == false then
        
        overtime = false
        music1Isagi:Stop()
        music2Sae:Stop()
        game.TweenService:Create(game.Workspace.CurrentCamera, TweenInfo.new(0.2), {FieldOfView = 70}):Play()
        
    end
end)
end)

local Players = game:GetService("Players")
local SoundService = game:GetService("SoundService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local StarterGui = game:GetService("StarterGui")

local plr = Players.LocalPlayer

local bgmusicEnabled = false
local musicThread
local awakenThread
local sfx

local music = {
    "rbxassetid://126478006472705",
    "rbxassetid://138210588552041",
    "rbxassetid://137856744878500",
    "rbxassetid://97581213878614",
    "rbxassetid://71371939631022",
    "rbxassetid://119592773299545",
    "rbxassetid://134456641764445",
    "rbxassetid://100509882059819",
    "rbxassetid://128623853689708",
    "rbxassetid://70979311703713",
    "rbxassetid://92420662159372",
    "rbxassetid://97837345641106",
    "rbxassetid://102469310336986",
    "rbxassetid://101851803743361",
	"rbxassetid://88021645218929"
}

local function notify(title, text)
    StarterGui:SetCore("SendNotification", {
        Title = title,
        Text = text,
        Duration = 3
    })
end

local function stopMusic()
    bgmusicEnabled = false

    if musicThread then
        task.cancel(musicThread)
        musicThread = nil
    end

    if awakenThread then
        task.cancel(awakenThread)
        awakenThread = nil
    end

    if sfx then
        sfx:Stop()
        sfx:Destroy()
        sfx = nil
    end

    notify("Background Music", "Disabled.")
end

local function startMusic()
    bgmusicEnabled = true

    local char = plr.Character or plr.CharacterAdded:Wait()
    local hum = char:WaitForChild("Humanoid")

    if SoundService:FindFirstChild("BGMusic") then
        SoundService.BGMusic:Destroy()
    end

    sfx = Instance.new("Sound")
    sfx.Name = "BGMusic"
    sfx.Volume = 1
    sfx.Looped = false
    sfx.SoundId = music[math.random(#music)]
    sfx.Parent = SoundService

    musicThread = task.spawn(function()
        while bgmusicEnabled and hum.Health > 0 do
            sfx:Play()
            sfx.Ended:Wait()
            if not bgmusicEnabled then break end
            sfx.SoundId = music[math.random(#music)]
        end
    end)

    awakenThread = task.spawn(function()
        while bgmusicEnabled and hum.Health > 0 do
            task.wait(0.2)
            local awaken = ReplicatedStorage.workspace.awaken.Value
            if awaken ~= nil then
                if sfx.IsPlaying then
                    sfx:Pause()
                end
            else
                if not sfx.IsPlaying then
                    sfx:Resume()
                end
            end
        end
    end)

    hum.Died:Connect(stopMusic)

    notify("Background Music", "Enabled.")
end

misctab:Toggle("Background Music", function()
    if bgmusicEnabled then
        stopMusic()
    else
        startMusic()
    end
end)

misctab:Label("Emotes.")

misctab:Toggle("Toosie Slide", function()
_G.isEnabled = _G.isEnabled or false

local animationId = "rbxassetid://95959941666543"
local soundId = "rbxassetid://1845341094"

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local animator = humanoid:FindFirstChildOfClass("Animator")

local animation = Instance.new("Animation")
animation.AnimationId = animationId

local animationTrack = animator:LoadAnimation(animation)

local sound

local function toggleState()
    _G.isEnabled = not _G.isEnabled
    
    if _G.isEnabled then
        animationTrack:Play()
        sound = Instance.new("Sound")
        sound.Name = "Toosie Slide"
        sound.SoundId = soundId
        sound.Looped = true
        sound.Parent = game.SoundService
        sound:Play()
    else
        for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
            track:Stop()
        end

        local existingSound = game.SoundService:FindFirstChild("Toosie Slide")
        if existingSound then
            existingSound:Stop()
            existingSound:Destroy()
        end
    end
end

toggleState()
end)

misctab:Toggle("Sae Pose", function()

_G.SaePose = _G.SaePose or false

local animationId = "rbxassetid://136812327261825"
local soundId = "rbxassetid://1843404009"

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local animator = humanoid:FindFirstChildOfClass("Animator")

local animation = Instance.new("Animation")
animation.AnimationId = animationId

local animationTrack = animator:LoadAnimation(animation)

local sound

local function toggleState()
    _G.SaePose = not _G.SaePose
    
    if _G.SaePose then
        animationTrack:Play()
        sound = Instance.new("Sound")
        sound.Name = "Sae Pose"
        sound.SoundId = soundId
        sound.Volume = 1
        sound.Looped = true
        sound.Parent = game.SoundService
        sound:Play()
    else
        for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
            track:Stop()
        end

        local existingSound = game.SoundService:FindFirstChild("Sae Pose")
        if existingSound then
            existingSound:Stop()
            existingSound:Destroy()
        end
    end
end

toggleState()
end)

misctab:Toggle("Assumptions", function()
_G.Assumptions = _G.Assumptions or false

local animationId = "rbxassetid://108778663919542"
local soundId = "rbxassetid://137023124734348"

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local animator = humanoid:FindFirstChildOfClass("Animator")

local animation = Instance.new("Animation")
animation.AnimationId = animationId

local animationTrack = animator:LoadAnimation(animation)

local sound

function Assumptions()
    _G.Assumptions = not _G.Assumptions
    
    if _G.Assumptions then
        animationTrack:Play()
        sound = Instance.new("Sound")
        sound.Name = "Assumptions"
        sound.SoundId = soundId
        sound.PlaybackSpeed = 0.17
        sound.Volume = 0.6
        sound.Looped = true
        sound.Parent = game.SoundService

        local eq = Instance.new("EqualizerSoundEffect")
        eq.LowGain = 10
        eq.MidGain = 0
        eq.HighGain = 4
        eq.Parent = sound

        sound:Play()
    else
        for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
            track:Stop()
        end

        local existingSound = game.SoundService:FindFirstChild("Assumptions")
        if existingSound then
            existingSound:Stop()
            existingSound:Destroy()
        end
    end
end

Assumptions()
end)

misctab:Button("Akuma Taunt", function()
local animationId = "rbxassetid://111005363990501"
local soundId = "rbxassetid://133370927301258"

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local animator = humanoid:FindFirstChildOfClass("Animator")

local animation = Instance.new("Animation")
animation.AnimationId = animationId

local animationTrack = animator:LoadAnimation(animation)

local sound = Instance.new("Sound")
sound.Name = "Akuma Taunt"
sound.SoundId = soundId
sound.Volume = 10
sound.Parent = game.SoundService

local function runOnce()
    animationTrack:Play()
    sound:Play()

    sound.Ended:Connect(function()
        sound:Destroy()
    end)

    animationTrack.Stopped:Connect(function()
        animationTrack:Stop()
    end)
end

runOnce()
end)

misctab:Button("Cartoon Fall", function()
local animationId = "rbxassetid://98064370044269"
local soundIds = { "rbxassetid://8663054927", "rbxassetid://4979513906" }

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local animator = humanoid:FindFirstChildOfClass("Animator")

local animation = Instance.new("Animation")
animation.AnimationId = animationId

local animationTrack = animator:LoadAnimation(animation)

local sound = Instance.new("Sound")
sound.Name = "Ragdoll"
sound.Volume = 10
sound.Parent = game.SoundService

local currentIndex = 1

local function playNextSound()
    if currentIndex <= #soundIds then
        sound.SoundId = soundIds[currentIndex]
        sound:Play()

        sound.Ended:Connect(function()
            currentIndex = currentIndex + 1
            playNextSound()
        end)
    else
        sound:Destroy()
    end
end
animationTrack:Play()
playNextSound()
end)

misctab:Button("Spit", function()
local animationId = "rbxassetid://97257010665720"
local soundId = "rbxassetid://18111052648"

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local animator = humanoid:FindFirstChildOfClass("Animator")

local animation = Instance.new("Animation")
animation.AnimationId = animationId

local animationTrack = animator:LoadAnimation(animation)

local sound = Instance.new("Sound")
sound.Name = "Spit"
sound.SoundId = soundId
sound.Volume = 2
sound.Parent = game.SoundService

animationTrack:Play()
sound:Play()

sound.Ended:Connect(function()
    sound:Destroy()
end)
end)

exploittab:Label("Semi-Private Server: People MAY Still Join Depending On Updates.")

exploittab:Button("Semi-Private Server Info", "This Comes With Instructions On How To Use The Feature Below.", function()
    local StarterGui = game:GetService("StarterGui")

    StarterGui:SetCore("SendNotification", {
        Title = "Semi-Private Server Info",
        Text = "If you end up in a server with another player, block someone.",
        Duration = 10
    }) wait(0.5)
    StarterGui:SetCore("SendNotification", {
        Title = "Semi-Private Server Info",
        Text = "After blocking a player in that server, run the feature to create a server again!",
        Duration = 10
    })
end)

exploittab:Button("Semi-Private Server (Method: 11v11)", "This Feature Creates A Server Where You Can Farm Goals / Quests!", function()
    game:GetService("TeleportService"):Teleport(85946466968831, game.Players.LocalPlayer)
end)

exploittab:Label("Instant Disconnect: Automatically Disconnects If Other Players Join.")

getgenv().limit = nil
getgenv().enabled = false

exploittab:Textbox("Instant Disconnect", "If More Than The Entered Number Of Players Join, You Disconnect.", function(v)
    local n = tonumber(v)
    if n then
        getgenv().limit = n
    else
        getgenv().limit = nil
    end
end)

exploittab:Toggle("Enable Instant Disconnect", "Toggles The Above Feature.", function(v)
    getgenv().enabled = v
    if v then
        game.StarterGui:SetCore("SendNotification", {Title="Instant Disconnect", Text="Enabled."})
    else
        game.StarterGui:SetCore("SendNotification", {Title="Instant Disconnect", Text="Disabled."})
    end
end)

game:GetService("RunService").RenderStepped:Connect(function()
    if getgenv().enabled and getgenv().limit and #game.Players:GetPlayers() > getgenv().limit then
        game.Players.LocalPlayer:Kick("Instant Disconnect Has Been Triggered.")
    end
end)

exploittab:Label("Goal Farming: Use At Your Own Risk, I Am Not Responsible For Bans.")

_G.GoalFarm = _G.GoalFarm or {
    Enabled = false,
    CFConn = nil,
    RenderConn = nil,
    StopAt = nil
}

buffer = buffer or {
    fromstring = function(str)
        return str
    end
}

getgenv().Players = game:GetService("Players")
getgenv().RunService = game:GetService("RunService")
getgenv().ReplicatedStorage = game:GetService("ReplicatedStorage")

getgenv().MapFolder = workspace:WaitForChild("map")
getgenv().AGoal = getgenv().MapFolder:WaitForChild("Agoal")
getgenv().BGoal = getgenv().MapFolder:WaitForChild("Bgoal")
getgenv().LocalPlayer = getgenv().Players.LocalPlayer

local function firePacketsIfNear()
    local char = getgenv().LocalPlayer.Character
    if not char then return end
    local root = char:FindFirstChild("HumanoidRootPart")
    if not root then return end
    if (root.Position - Vector3.new(-260, 4, -1474)).Magnitude <= 15 or
       (root.Position - Vector3.new(-262, 4, -1722)).Magnitude <= 15 then
        getgenv().ReplicatedStorage:WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\006\001\001\000A"))
        getgenv().ReplicatedStorage:WaitForChild("ByteNetReliable"):FireServer(buffer.fromstring("\006\001\001\000B"))
    end
end

local function IsInGame()
    local LocalCharacter = getgenv().LocalPlayer.Character
    if not LocalCharacter then return false end
    local StateFolder = LocalCharacter:FindFirstChild("state")
    if not StateFolder then return false end
    local InGameValue = StateFolder:FindFirstChild("ingame")
    if not InGameValue then return false end
    return InGameValue.Value
end

local function DisableCollisionBoxes()
    local MapFolder = workspace:FindFirstChild("map")
    if not MapFolder then return end
    local GkBarriar = MapFolder:FindFirstChild("gkbarriar")
    local AGoal = MapFolder:FindFirstChild("Agoal")
    local BGoal = MapFolder:FindFirstChild("Bgoal")
    if GkBarriar then
        local ABarriar = GkBarriar:FindFirstChild("A")
        local BBarriar = GkBarriar:FindFirstChild("B")
        if ABarriar then ABarriar.CanCollide = false end
        if BBarriar then BBarriar.CanCollide = false end
    end
    if AGoal then AGoal.CanCollide = false end
    if BGoal then BGoal.CanCollide = false end
end

local function StealBall()
    local LocalCharacter = getgenv().LocalPlayer.Character
    local LocalHumanoidRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
    local Football = workspace.Terrain:FindFirstChild("Ball")
    if LocalHumanoidRootPart and Football then
        task.wait(0.5)
        LocalHumanoidRootPart.CFrame = CFrame.new(Football.Position.X, 0, Football.Position.Z)
    end
    for _, OtherPlayer in pairs(getgenv().Players:GetPlayers()) do
        if OtherPlayer ~= getgenv().LocalPlayer then
            local OtherCharacter = OtherPlayer.Character
            local OtherFootball = OtherCharacter and OtherCharacter:FindFirstChild("Ball")
            local OtherHumanoidRootPart = OtherCharacter and OtherCharacter:FindFirstChild("HumanoidRootPart")
            if OtherFootball and OtherHumanoidRootPart and LocalHumanoidRootPart then
                task.wait(0.5)
                LocalHumanoidRootPart.CFrame = OtherFootball.CFrame
                local args = {
                    buffer.fromstring(buffers["base"]),
                    {
                        {
                            "tackle"
                        }
                    }
                }
                getgenv().ReplicatedStorage:WaitForChild("ByteNetReliable"):FireServer(unpack(args))
            end
        end
    end
end

local function HasBall()
    local LocalCharacter = getgenv().LocalPlayer.Character
    local Football = LocalCharacter and LocalCharacter:FindFirstChild("Ball")
    return Football ~= nil
end

local function stopGoalFarm()
    if not _G.GoalFarm.Enabled then return end
    _G.GoalFarm.Enabled = false

    if _G.GoalFarm.CFConn then
        _G.GoalFarm.CFConn:Disconnect()
        _G.GoalFarm.CFConn = nil
    end
    if _G.GoalFarm.RenderConn then
        _G.GoalFarm.RenderConn:Disconnect()
        _G.GoalFarm.RenderConn = nil
    end

    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Goal Farm",
        Text = "Target Reached! :3",
        Duration = 2
    })
end

local function trackGoalsLoop()
    task.spawn(function()
        local goals = getgenv().LocalPlayer:WaitForChild("leaderstats"):WaitForChild("goals")
        while _G.GoalFarm.Enabled do
            task.wait(1)
            local count = goals.Value
            if _G.GoalFarm.StopAt and count >= _G.GoalFarm.StopAt then
                stopGoalFarm()
                return
            end
        end
    end)
end

exploittab:Toggle("Goal Farm", "Automatically Farms Goals For You.", function()
    _G.GoalFarm.Enabled = not _G.GoalFarm.Enabled
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = "Goal Farm",
        Text = _G.GoalFarm.Enabled and "Enabled." or "Disabled.",
        Duration = 1
    })
    if _G.GoalFarm.Enabled then
        _G.GoalFarm.CFConn = getgenv().LocalPlayer.CharacterAdded:Connect(function()
            task.wait(1)
            if _G.GoalFarm.Enabled then
                firePacketsIfNear()
            end
        end)
        task.spawn(function()
            repeat task.wait() until getgenv().LocalPlayer.Character and getgenv().LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            if _G.GoalFarm.Enabled then
                firePacketsIfNear()
            end
        end)
        _G.GoalFarm.RenderConn = getgenv().RunService.RenderStepped:Connect(function()
            if not _G.GoalFarm.Enabled then return end
            pcall(function()
                if not IsInGame() then return end
                DisableCollisionBoxes()
                StealBall()
                if HasBall() then
                    local LocalCharacter = getgenv().LocalPlayer.Character
                    local LocalRootPart = LocalCharacter and LocalCharacter:FindFirstChild("HumanoidRootPart")
                    local Goal = getgenv().LocalPlayer.Team.Name == "A" and getgenv().BGoal or getgenv().AGoal
                    if LocalRootPart and Goal then
                        task.wait(0.5)
                        LocalRootPart.CFrame = Goal.CFrame
                        task.wait(0.185)
                        local args = {
                            buffer.fromstring(buffers["base"]),
                            {
                                {
                                    "kick",
                                    20,
                                    false,
                                    vector.create(0, 1, 0)
                                }
                            }
                        }
                        getgenv().ReplicatedStorage:WaitForChild("ByteNetReliable"):FireServer(unpack(args))
                    end
                end
            end)
        end)
        trackGoalsLoop()
    else
        stopGoalFarm()
    end
end)

exploittab:Textbox("Goal Target", "Enter a number of goals to stop farming at.", function(v)
    local num = tonumber(v)
    if num then
        _G.GoalFarm.StopAt = num
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Goal Target",
            Text = "Goal Target: " .. num,
            Duration = 2
        })
    else
        _G.GoalFarm.StopAt = math.huge
        game:GetService("StarterGui"):SetCore("SendNotification", {
            Title = "Goal Target",
            Text = "Invalid Target, Farm Will Be Infinite.",
            Duration = 2
        })
    end
end)

loadstring(game:HttpGet("https://raw.githubusercontent.com/ghostofcelleron/Scripts/refs/heads/main/oldthingyep",true))()
loadstring(game:HttpGet("https://pastebin.com/raw/rQMS2B9R",true))()
